0:01.
all right um welcome to six s081 operating systems.
0:08.
um i'm robert i'll be co-lecturing with franz and david and nicholas for the tas.
0:17.
please during these zoom lectures ask questions you can either interrupt me by audio or enter something.
0:24.
into the chat window and one of the staff will see an ask question for you and by the way we'll be.
0:30.
recording these lectures and we'll post the recordings later so you can review them or for.
0:36.
people who can't make this time so they can never like see the lectures all right i want to start by um.
0:43.
laying out some of the goals of the course so number one is to um understand.
0:50.
uh the design and implementation of operating systems and you know the uh.
0:58.
design is sort of high-level structure and implementation is really about what the code looks like.
1:04.
and we'll be spending a lot of time with both um and in the interest of.
1:11.
getting a deep understanding of what's going on you'll get hands-on experience with a small.
1:21.
with a small operating system the xv6 operating system.
1:26.
and in addition to actually looking at an existing operating system you'll be in the labs get a bunch of.
1:33.
experience extending the operating system modifying improving its behavior and writing system software that um it.
1:41.
uses the operating system interfaces if it works an application.
1:46.
so um so this is what you're going to be doing in the course.
1:52.
we're also interested in what the purpose of the operating system itself is as well as of the course.
2:00.
so for that i have a sort of list of a couple of things which um you know there's lots of operating.
2:07.
system different operating systems out there they typically have a common set of purposes.
2:16.
one of them is to abstract the hardware.
2:21.
um that is you know what you're given typically as a kind of starting point is you buy a computer a computer as a cpu.
2:27.
in memory but that's a very low level uh set of resources it's fantastic to have much higher level.
2:33.
um interfaces and abstractions that applications can use such as processes or file systems both.
2:41.
for convenience and for portability another very important.
2:46.
task of an operating system is to multiplex the hardware among many applications you might be.
2:53.
running a text editor and a compiler or maybe multiple different database.
3:00.
servers or something on your operating system it's fantastic to be able to have the operating system run both of them at the.
3:05.
same time or all the things are going on at the same time without having them interfere that's.
3:11.
often called multiplexing um because there may be a lot of things happening on the operating system at the.
3:17.
same time it's it's critical that they not interfere unintentionally even if they have bugs.
3:23.
and that's a task is called isolation the idea that.
3:30.
different activities should not be allowed to interfere on the other hand there are times when different activities would like to.
3:36.
interfere we'd like to interact or cooperate so for example if i create a file with a text editor.
3:42.
and i'd like my compiler to read the file we definitely want to allow that kind of sharing.
3:48.
so we want to allow sharing when it's sort of what the user has in mind um.
3:55.
but in many circumstances the user doesn't want sharing maybe you're logged into a time sharing machine like athena and.
4:02.
you don't want other people to read your files so we also need as well as sharing we want to not share when we don't want to.
4:09.
which we could call security or a permission system or an access control system.
4:16.
another thing that people value in operating systems is if you spend a lot of money on hardware on a computer.
4:21.
you'd like your application to be able to get the sort of full performance that the hardware ought to be able to.
4:27.
provide and you know a lot of that is just application programming.
4:34.
but inevitably unfortunately some of it is the operating system has to make sure that whatever services it provides.
4:42.
don't get in the way of applications getting high performance so you want to at least not get in the.
4:47.
way and maybe even help applications achieve good performance.
4:56.
finally with most operating systems have to support a wide range of.
5:02.
different applications maybe it's a laptop running a text editor maybe it's running games.
5:07.
maybe your operating system needs to support database servers or cloud computation and usually because.
5:14.
operating systems are quite expensive to design and build people use the same operating systems.
5:20.
for many different tasks like linux for example which i'm sure many of you are running is used in all of the situations i mentioned so.
5:27.
the same operating system really has to be able to support a range of often quite different uses.
5:36.
so we're hoping to be able to support um sort of all these different goals uh simultaneously um and we'll hear more.
5:44.
about all of them during the course all right uh operating systems.
5:49.
uh sort of people worked out a set of um design ideas over the decades that have.
5:56.
worked pretty well sort of ways of organizing things and i'm going to lay out for you the sort of.
6:04.
classic organization it's a sort of standard deal for uh for this course and.
6:13.
um is actually quite common around for many operating systems so this is sort of you know os internal organization or.
6:21.
um the way i think about it is a in terms of a draw a box for the.
6:28.
computer um the computer sort of comes with a bunch of hardware resources.
6:33.
which i'll put at the bottom maybe there's cpu and ram and a disk for storage.
6:39.
and maybe a network interface so this sort of hardware that's the lowest layer um so if at the top.
6:47.
we want to run various applications maybe a text editor i happen to use vi as a text editor if you're going to.
6:53.
run a c compiler say cc you know if you run lots of other things we're going to talk a lot today.
6:59.
about the shell which is the command line interface so we have all.
7:04.
these different programs that are running and this is the sort of world in which.
7:10.
applications run is usually called user space and as distinct from that there's a.
7:16.
single program um a special program that's always running called the kernel and the kernel.
7:23.
is sort of the guardian of the resources of the computer it's what first boots up you turn on the computer.
7:30.
there's just one of it it maintains data to help it manage each of these processes and the kernel also maintains.
7:37.
lots of data structures to help it interface and all the different kinds of.
7:43.
hardware that uh these user programs need to use.
7:49.
the kernel also has built in a bunch of services um and so for example there's typically a.
7:56.
file system implementation inside the kernel that implements things like file names and.
8:02.
file contents and directories and understands how to store the files in the disk so your programs.
8:08.
are going to talk to the files inside the kernel and the file system implementation is going to talk to the disk and in this course.
8:17.
what we mostly focus on is all the things that have to happen inside the kernel and on the interfaces between user.
8:24.
programs and the kernel as well as the sort of structure of the software.
8:30.
inside the kernel so we care a lot about these services inside the kernel.
8:37.
[Music] one of them is the file system i mentioned there's also uh.
8:43.
management of processes each of these running programs is called a process and it has things like its own memory for example.
8:50.
as well as a share of the cpu time so kernel manages.
8:56.
processes as a kernel service [Music].
9:02.
the kernel manages the allocation of memory the different processes need.
9:07.
different amounts of memory the kernel multiplexes and divides up the memory.
9:13.
allocates the memory among all the different processes.
9:22.
um the kernel as i mentioned influenced the file system file system really comes in two or three.
9:28.
logical or a bunch of logical parts but for now we can think of it in terms of managing file content that's what's.
9:35.
inside files figuring out where on disk each file's content ought to live the.
9:40.
file system also somewhat separately manages a name space each file has a name and there's a hierarchy of directories.
9:48.
every directory has a bunch of files in it all that's managed by the file system there's typically.
9:55.
some sort of security arrangement maybe we'll call it access control.
10:01.
by which the colonel decides that you know when a given process wants to read use some resource maybe read something.
10:07.
from the disk or use some memory the access control machinery inside the kernel is what gets to decide yes is that allowed is that not allowed.
10:14.
and that can get pretty complicated if we're talking about time sharing systems like athena systems where there's.
10:19.
you know each of these processes may be run by a different user and have different access control rules.
10:24.
applied to what it's allowed to get at and in a real.
10:29.
full-blown operating system there's turns out to be many many other services you know there's typically some way for.
10:35.
different processes to talk to each other called inter-process communication there's typically a whole bunch of.
10:41.
software associated with the network things like the tcp ip protocols for talking in the network.
10:49.
there's typically support for sound cards there may be drivers for hundreds of different disks and hundreds of.
10:55.
different network cards so in a full blown operating system there's a huge amount of stuff here and this may run to millions of lines of.
11:02.
code inside the kernel so that's sort of a quick overview of.
11:07.
what's inside the kernel we're also interested in how applications interact with the kernel.
11:13.
and what that interface looks like.
11:19.
the usual so this is the api.
11:26.
for the kernel how applications get at the kernel.
11:33.
typically that's done with something called system calls and these are things that look like function calls that programs.
11:39.
can make but actually jump into the kernel and execute a.
11:45.
system called implementation in the kernel i'll talk a bunch about that in the latter part of this lecture for now just to give you a.
11:52.
flavor here what a couple of different system calls might look like in the source code of an application.
12:00.
one might be that if you want if an application wants to open a file it make it calls the open system call.
12:07.
and tells the open system called the name of the file so maybe it wants to open a file for.
12:12.
writing called out and it would be an extra argument here saying one in this case saying i want to write that file.
12:18.
and so this thing that looks like a function call if opens the system calls actually.
12:24.
special code that jumps into the kernel and the kernel can retrieve these arguments execute some kernel code that implements.
12:30.
open maybe talks to the disk and then returns a value and that's this file descriptor.
12:36.
as fd stands for file descriptor which is the program can then use as sort of a.
12:41.
handle to refer to this open file if you want to write to a file the.
12:48.
system called to do that is called write you have to pass it one of these file descriptors.
12:53.
the same as was returned by open um these are now arguments that are passed in the system call.
12:59.
from the program into the kernel you give it a pointer to a buffer of characters so an easy way.
13:06.
to do that in the c programming language which these examples are written by is the double quotes and then.
13:12.
the string the bytes of the string this backslash n is a new line and the third argument is the count of.
13:18.
characters that you want to write and so this really gets point passed as an address.
13:24.
in memory so you're telling the kernel look please write six bytes from this address to the file that this file descriptor.
13:31.
refers to a much more exciting uh system call that you encounter is the fork system call.
13:39.
fork is the system call that creates a new process um and it returns actually creates a.
13:46.
process that's identical to the caller and fork returns the an identifier the.
13:51.
process identifier or pid of the new process it's actually a little more complicated than that and.
13:57.
we'll hear more about this so again these are all look like function calls.
14:04.
but the system calls are special because they jump into the kernel that's just taste i'll see more later.
14:15.
well that is a sort of quick overview um i want to just mention why i find.
14:22.
operating the study of operating systems to be both challenging and interesting.
14:32.
why you know why it's maybe worth intellectually worth taking a course in.
14:37.
this area so one reason why it's hard is that the environment's unforgiving the.
14:43.
programming environment inside the kernel is unforgiving because you're.
14:50.
you're when you're programming when you're modifying the kernel or extending the kernel writing a new operating system kernel.
14:55.
you're providing the infrastructure that everybody else assumes is already present to run their programs.
15:01.
right and everybody else gets an operating system under their program when they write ordinary application programs but.
15:07.
when we build operating systems what we get is the hardware underneath our operating system which turns out to.
15:14.
be more difficult to deal with in this course we we get to use a hardware simulator.
15:20.
called qmu that you know simulates a cpu and a computer and that makes life a little.
15:26.
bit better but it's it's still a kind of a difficult environment to program it.
15:32.
another reason why it's hard and interesting is because if you're designing an operating system you have to satisfy a bunch of.
15:38.
tensions that require real design thought so one is that you'd like your operating.
15:44.
system to be both efficient which often means that it sort of operates at a low level close to the.
15:50.
hardware but for ease of use and because real live people have to write programs.
15:56.
that use your operating system we'd like it also to be provide abstract high-level portable.
16:03.
interfaces and it's a neat trick to provide abstract interfaces that are simple um affordable but that are also.
16:10.
efficient another tension is that we'd like to provide a very powerful.
16:16.
operating system services so that the operating system can shoulder a lot of the burden.
16:22.
of running programs we'd like to powerful operating system services.
16:29.
but we also want to have simple interfaces.
16:35.
that is we don't want tremendously complex hard to understand interfaces for programmers to use because.
16:41.
they're not going to understand them and they may find it hard to use um so this is really simple api and so.
16:48.
this is possible to do to provide simple interfaces that have powerful machinery.
16:55.
inside them and so we'll always be searching for sort of simple interfaces that provide.
17:02.
powerful services hey robert we have a question in the chat uh what is unique slash different about.
17:09.
saying system calls jump into the kernel i.e as opposed to a standard function call that jumps to another function.
17:18.
well the colonel has the kernels um a piece of code that's always resident.
17:23.
that has special privileges that were that because it booted the machine booted the kernel.
17:30.
um the kernel has special inter privileges that can get directly at all kinds of hardware like the disk.
17:35.
device that ordinary user programs can't get at so if you make a fun an ordinary function call um.
17:43.
the the function you're calling doesn't get it just doesn't get any special privileges with respect to the hardware.
17:49.
whereas if you make a system call into the kernel um we'll talk about how this works but that.
17:54.
ends up um as it when it jumps into when the system call jumps into the kernel.
17:59.
the system call implementation in the kernel then gets all these special privileges so that it it can modify all kinds of.
18:07.
sensitive and protected uh hardware resources like for example getting directly at the.
18:13.
hard disk we'll see a lot more detail for all this uh shortly okay so.
18:21.
a final tension that we wanna that all operating systems need to satisfy is you wanna give programs as much flexibility.
18:26.
as you can you don't want to constrain them so you want to have very flexible.
18:33.
interfaces but you do need to constrain programs somewhat because you absolutely have to have some notion of security.
18:39.
you can't you we'd love for programs to give programmers complete freedom but it.
18:44.
can't be complete can't be really complete because we don't want programs to get directly at the hardware or to interfere.
18:50.
with other programs or to sort of be able to interfere with the operation of the.
18:55.
operating system itself so these are all you know it's possible to do a good job.
19:02.
and we'll talk a lot about it but it's always a bit of a puzzle to provide sort of both of these.
19:08.
the properties in both of these columns another thing that makes os design hard.
19:13.
and interesting is that operating systems provide a lot of features and a lot of services but they actually tend to interact.
19:20.
and sometimes in odd ways they require a lot of thought so even in the simple examples i gave.
19:26.
with open and fork those two interact actually if a program allocates a file descriptor with the.
19:32.
open system call and then that same program forks and the semantics of fork.
19:41.
just turn out to be that you create a new process that's a copy of the current process this file descriptor you opened.
19:49.
if that's truly to be a copy this file descriptor still has to um be present and usable in the child.
19:56.
and you know so that's to be thought through that is the files the open and filed scripters interact with fork in.
20:01.
this interesting way and somebody has to figure out oh should the child be able to.
20:06.
get at the file descriptors created before fork was called and the answer happens to be yes in the.
20:12.
operating systems we're going to look at all right and so other things that are.
20:18.
turned out to be interesting i already mentioned that operating systems have to cater to a wide variety.
20:24.
of uses the same os used both for database servers and and smartphones for example.
20:31.
and operating systems as time goes on the hardware that you run the hardware.
20:37.
you get with typical computers changes maybe you get super fast ssd storage instead of mechanical hard drives for.
20:44.
example about 15 years ago multi-core computers went from being rare curiosities to.
20:51.
being pervasive and recently we've seen you know order of magnitude speedups in how.
20:57.
fast networks operate and so all these require rethinks um.
21:02.
periodically of how operating systems are designed now um so so those are those are sort of.
21:10.
intellectually why you might take the course there's also some even more practical reasons why you might be glad.
21:16.
to have taken this course one is if you're interested in what happens inside computers what goes on under.
21:21.
and saw under the hood sort of in secret when you turn on your computer this is a good course to take similarly.
21:28.
if you like infrastructure that is if if you enjoy building uh sort of services that other.
21:33.
programs can then use this is of course essentially all about infrastructure because that's that's.
21:39.
what operating systems are if you ever need to spend a lot of time tracking down bugs in.
21:45.
application code or tracking down security problems often that um involves understanding.
21:51.
what was going on inside the operating system because it's ultimately the operating system that enforces a lot of security.
21:57.
and when things go wrong it's sort of the operating system that has to pick up the pieces so that's often involved in uh tracking.
22:05.
down bugs and finally yes two more questions from the chat so the first is how important is it for.
22:11.
application developers to truly deeply understand the operating systems they're developing their applications for.
22:16.
do they necessarily need to be experts you don't have to be an expert but if you spend.
22:22.
um a lot of time developing and maintaining and debugging applications you'll eventually end up knowing a lot.
22:28.
about the operating system whether you whether you meant to or not it just.
22:34.
it just comes up and you're often forced to understand.
22:39.
and the second question is do high-level programming languages like python use system calls directly are.
22:45.
there built-ins slash wrappers for convenience a lot of high-level languages are.
22:50.
sort of at one remove from system calls that's absolutely true so.
22:56.
partially because a lot of languages want to provide portable a portable environment that.
23:02.
works on many different operating systems so they can't necessarily commit to the specific system calls of any one.
23:08.
operating system um so i'm the answer the question i think is if you use python.
23:14.
uh you're somewhat insulated from the system call interface you know internally of course python makes.
23:20.
has to make system calls to get its work done and certainly in python and many other.
23:25.
languages there is usually a way to get directly at the system calls of whatever.
23:31.
your operating system you're running on and folks for questions you can just.
23:37.
feel free to jump in yourself and ask questions you don't need to go through the chat.
23:43.
okay um all right sorry um.
23:50.
i'm going to spend a couple of minutes now talking about the class structure of.
23:57.
6 s081 before switching back to actual.
24:04.
technical content so the uh there's a website for the course which i don't want to write out.
24:09.
just now but it's um you can find it by looking for 6s 081 on google and the website um has.
24:19.
um the schedule uh it has the assignments on the schedule.
24:26.
it has the lab assignments um and it has the sort of information about course structure like.
24:32.
the grading policy on it the other big resource you're gonna want to keep track.
24:37.
of is piazza i guess everybody who's here got here by the way piazza but.
24:43.
as well as so we use piazza really for two main things one is as a way of people to be able to ask.
24:50.
questions about the lab assignments and uh course staff will try to answer these.
24:55.
questions but you should feel absolutely free to answer each other's questions as well and the other big thing that happens on.
25:01.
piazza if there's announcements if there's any announcements about the course we'll put the announcements on piazza so.
25:07.
you should keep an eye on piazza for announcements even if you're not using it for lab help.
25:16.
the one of the big parts of the course is that these lectures.
25:22.
the lectures will cover basic ideas in operating systems.
25:30.
some of the lectures will be devoted to detailed study of the code in xv6 which is our.
25:36.
small teaching operating system and so talk about how it works we'll look at the code and sort of show the.
25:43.
code executing during lectures and in addition before many of the lectures there'll be assignments.
25:48.
reading assignments from a book that sort of describes how xv6 operates and why it's designed that.
25:55.
way so you should do the readings before the class so that you'll understand.
26:00.
the discussion in the class some of the lectures are devoted to background to help you do the labs sort.
26:07.
of explanations about c works of how the risc 5 which is the microprocessor that we'll be using.
26:13.
that you'll find helpful in in understanding how to do the labs and towards the end of the course i will.
26:20.
spend some lectures discussing some operating system papers um research papers and and some classic.
26:26.
papers in the field which uh you know we'll ask that you read before the lectures and then we'll sort of talk about the.
26:33.
papers in during the lecture for all the lectures or almost all the lectures we ask that you submit a question about.
26:39.
the reading for the lecture before the actual time.
26:44.
of the lecture which many or all of you did for this lecture for which thank you.
26:49.
and we will read those questions to help us guide us about what to talk about and.
26:55.
we'll try to answer as many of the questions as we can although there's rarely time unfortunately for us to answer all of.
27:01.
them the next big part the course of the labs there's a programming lab.
27:07.
do almost every week and the point of the labs is to help you.
27:13.
get hands-on experience with implementing and using operating systems.
27:20.
um the lab that's due next week is actually about using using about.
27:26.
writing applications that make the call the system calls we'll be talking about um.
27:31.
whereas most of those labs after that are involve you either implementing basic operating.
27:37.
system features or adding uh kernel extensions to the xv6.
27:42.
uh operating system the very last slab and one in which you actually add a network.
27:48.
stack and a network driver so you'll be able to connect in over the network to the operating system that you run um.
27:55.
you should if you have problems with the labs uh there'll be office hours that the um tas will hold in addition.
28:03.
you can post questions to piazza and very often you'll be able to get useful answers.
28:08.
from piazza more quickly than from office hours we welcome you discussing the labs.
28:15.
talking about the labs talking about how to design the lab solutions but we ask you.
28:21.
please do not look at other people's solutions for the labs please all the code you write should be your own and.
28:26.
you shouldn't share code or look at other solutions.
28:32.
the grading for the course will be mostly determined.
28:40.
from the labs this year so 70 of the grade will be um uh based on.
28:48.
whether or not that your lab the lab you submit passes the tests and we for grading we run the same tests.
28:53.
um that we supply you so if your lab passes the all the tests that we give you then chances are you get full credit.
28:59.
for the lab um 20 of the grade um is going to be from lab check off.
29:05.
meetings uh we'll for each of you we'll pick a couple of randomly selected labs.
29:11.
and one of the teams will talk to you and ask you questions about your implementation just to make sure that.
29:17.
you really understand what's going on so this lab check-offs.
29:23.
there's um ten percent remaining there's a question be like a.
29:30.
yes or no one or zero type of thing or would they be like could someone get like if they.
29:38.
answered some of the questions right but not all the questions right would they get in between so they're great you know i.
29:45.
haven't thought this through um there's certainly room for partial credit but.
29:51.
it's not a it won't be binary it'll definitely be you can receive partial credit okay.
29:59.
all right um the last 10 is going to be driven by the homework and participation during lecture and in.
30:06.
piazza there'll be no exam or quizzes.
30:13.
this year um and so what that means is that most of the.
30:18.
you know ninety percent of the grade is being driven by the lab so.
30:23.
you know you should spend a lot of time in the labs make sure that you start early and have.
30:29.
enough time to complete them and work out bugs in order to get full credit.
30:37.
and you know as a result of that this is going to be a very kind of hands-on software oriented course or any.
30:44.
questions about the machinery of the course.
30:53.
uh we've got a couple questions in chat so the first is a logistical question.
30:59.
currently 6s081 isn't listed as usable for the systems concentration in the are there plans added to the list of.
31:05.
classes later i think for that because it's not an aags it's an aus.
31:10.
it can't be used to fulfill mn requirements as it's not a graduate level class but.
31:19.
um and then we have is the only homework to submit questions looking at the calendar that appears to be the case.
31:28.
unless i'm forgetting something i think that's the case yes so.
31:35.
have uh are there gonna be cutoffs for grades like x percent gets an a.
31:40.
y percent gets a b etc no no um.
31:48.
you know we're going to try to free student estimate um.
31:54.
our impression of how well you've understood the material and assign a grade based on that so.
32:00.
there's there's no predetermined cutoffs.
32:07.
all right anything else.
32:13.
all right just real quick for folks in the chat uh asking about the.
32:21.
concentration requirement i'm not a hundred percent certain uh but six soa one is not it's like a.
32:27.
temporary number before the class gets this official one so it certainly won't be uh listed anywhere if you needed to.
32:34.
fulfill a concentration i think your best bet is probably to fill out a petition or to email somebody like katrina.
32:39.
lakerts to see what the status is we don't control.
32:45.
you know what what classes fill these kind of requirements unfortunately and for what language.
32:52.
we'll be using the class will be in c.
32:58.
all right um all right for the rest of the lecture i.
33:04.
want to uh talk about how um house what system calls look like to applications.
33:11.
and you know since the system calls are the interface to the services that the.
33:16.
operating system provides it it's actually pretty important what those system files look like what applications expect from system calls.
33:23.
and how they behave so it's sort of worth understanding what the interface looks like.
33:29.
you'll be using the system calls we talk about in the first lab and extending and improving the.
33:36.
implementation internal implementation of these system calls in subsequent labs what i'm going to do is show some simple.
33:43.
examples of little programs that call system calls and then i'll run.
33:51.
them and and next v6 for you um i'm going to run them the xv6 is a it's.
33:58.
a unix a simplified unix-like operating system unix is a old operating system sort of at least.
34:06.
intellectual basis for many present day operating systems such as linux and os x so it's in very common use.
34:14.
xv6 our teaching operating system is much simpler.
34:19.
it's sort of inspired by unix and has the same overall structure but is dramatically simpler than any real unix.
34:26.
operating system and it's simple enough that hopefully um.
34:33.
you know it would be relatively straightforward for you to read all the source code as well as read the book um in a couple.
34:41.
of weeks certainly during the semester in order to kind of understand all of what happens inside xv6.
34:49.
x86 runs on the risc-5 processor risc-5 microprocessor and this is the.
34:55.
same microprocessor that's the focus of recent 6004 so many of you may actually know quite a.
35:02.
bit about the risk 5 instruction set in theory you could run xv6 on top of a.
35:09.
risk 5 computer and people have done that.
35:14.
but we're going to run it under the qmu machine emulator so just to write this.
35:19.
down we got our operating system is xv6 it runs on risk 5 microprocessor.
35:28.
and not just risk 5 microprocessor but we assume a certain amount of surrounding hardware like.
35:34.
memory and a disk and a console interface for us to talk to it um but we.
35:40.
actually run under the qmu machine simulator so that which.
35:49.
runs under linux so that all of you can actually run xv6 without having to have hardware.
35:56.
okay so i'm gonna switch to uh showing you.
36:10.
code all right so um first thing is.
36:18.
i've uh set up xv6 on my laptop um and i'm going to run it and type make.
36:25.
qmu which you'll find yourself doing quite a bit during the labs um which compiles xv6 it's written in c.
36:30.
so it's compiled with a c compiler maybe i'll make clean for you so you can see the actual.
36:37.
compilation and i might type make qmu which has the effect of compiling and building xv6 kernel and.
36:44.
all the user processes and then running them under the qmu emulator.
36:51.
it takes a moment to run the compiles and now we're up and running xv6 and the.
36:59.
dollar sign prompt you see is the shell which is the command line interface to.
37:05.
xv6 modeled after the shell on unix which is if you log into an athena workstation.
37:12.
it's the it's like the shell that athena shows you.
37:18.
x36 is itself tiny and it comes with a small number of utility programs and including for example the ls program.
37:25.
which i'm about to run run ls and it gives me a list of all the files in xv6 of which there are only.
37:32.
about two dozen including things like grep and kill and make deer.
37:38.
and rn which may be familiar to you as uh as unix utilities.
37:44.
okay the first program i'm going to show you to illustrate system calls is um program called copy.
37:59.
um here's the source it's just a page.
38:08.
and so what you're seeing here is a program that starts on line eight and main there's the sort of convention for c.
38:14.
programs it sits in a loop at line 12. and over and over again it reads some.
38:21.
data as input and on line 13 and then writes the data just read to its output on line 16. if i run copy.
38:32.
uh in xv6 just waiting to read input if i type some input and reads it and spits.
38:39.
it back out to me so it's very simple program just does i out.
38:45.
it's written in c as i mentioned um if you're you don't already know c it's worthwhile getting the.
38:50.
um standard c programming language book by kernhan and ritchie and i think there's a more full.
38:58.
reference to it on the course website which explains to you in a.
39:03.
very straightforward way how to program and see.
39:08.
as i mentioned before read and write this this program makes two really three system calls read write.
39:13.
and exit are system calls if you look at the call to read on line 13.
39:20.
it takes three arguments the first argument is a file descriptor which is really a reference to a previously open.
39:26.
file and the shell uh ensures that when a program starts by default its.
39:33.
file descriptor 0 is connected to the console input and its file descriptive 1 is connected to the.
39:40.
console output and that's why i was able to type to this copy program and see the output.
39:49.
of course you know these file descriptors are expected the program expects these file descriptors have been.
39:54.
previously opened and set up by the shell for it and this this zero one file descriptors is a pervasive unix.
40:02.
convention many many unix programs expect to read and file descriptor one and read file.
40:08.
scripture zero and write to file description one um the second argument to read is a.
40:14.
pointer to some memory um where the program is asking the operating system to read data.
40:21.
into that address and memory so that's the buff argument and line 10 allocates 64 bytes of memory.
40:28.
on the stack per read to read into and the third argument to read is the.
40:33.
maximum number of bytes that the program wants to read and the size of buff says just 60.
40:38.
maximum 64 buckets so the recall reads up to 64 bytes from whatever.
40:44.
is connected to file descriptor zero and that was my terminal in this example the return value from read it either.
40:51.
repeat it which may return the number of bytes read which would be six in the case of.
40:58.
me typing xyz y um lead might be reading from a file if it gets to the end of the file there's no.
41:04.
more bytes read will return zero i know some other error occurred like.
41:09.
the file descriptor doesn't exist read may return minus one and so.
41:14.
in many of these examples like on line 16 there i don't my example code doesn't check.
41:21.
system call returns for errors um but you should be more careful than me um.
41:27.
uh the you should figure out how system calls reflect errors is usually a minus one return value.
41:33.
and check all system call returns for errors and if if you want to know what the.
41:39.
system call arguments and return values are there's a table and i think chapter 2 in the book that.
41:45.
explains all of the xv6 system call arguments and.
41:50.
return values the question regarding the resist call what if we set the max read.
41:57.
bytes to size of buff to one plus size of buff or bigger so what if we try to read more than the.
42:02.
size yeah then if there was 65 bytes to read then the operating.
42:08.
system would happily we'll just copy those 65 bytes to the memory that you provide and of.
42:15.
course there's something else on the stack up there maybe the return program encounter or an argument or something.
42:21.
and so if you pass 65 then you're inviting the colonel to write junk um to an unexpected place in.
42:28.
your stack and so that's a bug and it may cause you for him to crash.
42:34.
or do something else unexpected um so as a programmer you're you have to be careful here there's nobody.
42:40.
writing in c with these kind of interfaces there's it's very very easy to write code that.
42:47.
the compiler is happy with and will run but absolutely does the wrong thing.
42:53.
so that's too bad but um that's the way it is.
43:00.
okay uh one thing to note is that this copy program and indeed the read and write system calls.
43:06.
they don't care about the format of data they're reading or writing they just read them write and read and.
43:11.
write and this copy program just deal with 8-bit bytes with streams of 8-bit bytes.
43:18.
how you interpret them is totally up to the application so the application maybe parse these as data records or as c.
43:26.
source code or who knows what the operating system um.
43:32.
it only thinks in terms of a stream of 8-bit bytes okay so copy assume this code my copy.
43:39.
program assumed that the file descriptors were already set up um but we need to we need to have a way.
43:44.
to create file descriptors and the most straightforward way to do that is um.
43:50.
with the open system call and so here's the source for a program that called open that.
43:58.
uses the open system call a question from the chat what do you mean by a stream of bytes.
44:07.
i i i just mean that if a file contains a bunch of bytes.
44:12.
then read and successive yes building a file contains a million bytes if you make a sequence of recalls each.
44:19.
for 100 bytes it'll just read the first hundred bytes and then the second hundred bytes and then.
44:24.
the third hundred bytes um that's all i mean.
44:31.
all right so this program um called open first i'll run it for you what it does is uh opens creates a new.
44:40.
file called output.txt and then writes some bytes to it and then it finishes so we.
44:45.
don't see anything because it broke data to this file it opened but we can look at this output.txt file that it.
44:52.
created and see the ooo that it wrote there so line 11 in the program is.
45:00.
makes the open system call gives it a file name output.text and the o underscore stuff um in the second.
45:08.
argument to open are flags that tell the open system call implementation in the kernel that we'd.
45:14.
like to create a file with its name and that we're going to write it open returns a newly allocated file.
45:20.
descriptor and the file the script is just a small number it's probably two or three or.
45:26.
four or something and then we pass that same file descriptor to write along with a buffer.
45:32.
and a number of bytes to write that writes data to the file that the file descriptor refers.
45:39.
to what that file descriptor is actually doing is indexing into a little table.
45:45.
inside the kernel the kernel maintains state for each process that's running each program that.
45:50.
you run and among other things the kernel remembers a table for every running process of index by file.
45:57.
descriptors and the table sort of tells the kernel what each file descriptor.
46:02.
refers to.
46:08.
a critical point is that each process has its own sort of space of file descriptors so uh.
46:15.
before running two different processes two different programs and different processes and they both open a.
46:20.
file they may actually get the same number back as a file descriptor but because the kernel maintains a.
46:25.
separate file descriptor for each process the same file descriptor number may.
46:31.
refer to different files in different processes.
46:36.
any questions about open about this little program yeah we got a question in the chat a question from someone not familiar with.
46:43.
c uh how are these files being described different from normalc programs is it because we're only using.
46:49.
kernel calls i.e couldn't we also open or write a file in python.
46:59.
i don't think i understand that it's a c program that's opening and writing a.
47:08.
file um okay.
47:15.
i think i'm gonna move on um all right so.
47:23.
you um ask what actually happens when uh maybe the question is whether someone is doing.
47:29.
it in c any different than doing it in python minus the syntax.
47:34.
well it's it's not really um.
47:40.
there's certainly ways to um python provides nice function calls for.
47:47.
opening and doing all these things or opening files for example in reading writing files um they're sort.
47:54.
of a layer of they're higher somewhat higher level functions typically um not you know.
47:59.
pointers to memory for example um and python does more error checking for.
48:05.
you but when you open a file in python or write a file in python the.
48:11.
python calls you make boil down to system calls just like these.
48:19.
is that a good answer.
48:25.
i think so all right.
48:31.
all right um all right i've been over here talking to the uh.
48:39.
xv6s unix like shell and the shells what people often.
48:44.
call the command line interface as opposed to some more graphical user.
48:49.
interface the shell turns if you haven't used the cell the shell turns out to be.
48:56.
a pretty useful interface for things like system management of unix systems.
49:01.
it provides a lot of utilities for uh messing around with files and for programming development and for.
49:07.
writing scripts to do all these things so you saw me before run i just want to demonstrate a few shell.
49:14.
features ordinarily when you type things um you're telling the shell to run a.
49:19.
program so when i type ls what that means is i'm asking the shell to run the program.
49:25.
whose name is ls and what that really means is there's a file in the file system called ls that.
49:31.
contains some instructions some machine instructions and i'm asking the shell to run.
49:37.
the instructions that are in the file called ls run ls now ls what it actually does is.
49:44.
get a listing of the files in the current directory and you can see up there on the fourth line that among the other files that.
49:52.
ls says exists in this list is a file called ls which is in fact the file containing.
49:58.
the instructions i just ran the shell does a few other things for you other than running programs.
50:05.
it allows you to redirect io so for example if i say ls greater than out.
50:11.
what that means is i'm asking the shell to run the ls command but with its output redirected.
50:16.
to the file called out and i run ls we don't see any output because the.
50:22.
output all went out um now i can out contains a bunch of.
50:27.
data um we could the cat command reads a file and displays the contents.
50:34.
of the file so i say cat out i'm just going to see now the now this is the saved output.
50:40.
of ls you can also run a command like grep and i can give it an argument x and what grep x is the grep command searches for.
50:47.
patterns again um if i run grep x it's going to search for lines of.
50:55.
input that contain x i can redirect tell the shell to redirect its input from the file out.
51:01.
in order to look for instances of x in that saved ls output.
51:07.
and turns out there's three files um whose names contain x's.
51:14.
um we're going to spend a bunch of time with the shell um it the shell is sort of the most.
51:21.
traditional um and fundamental interface to uh to unix because when units was first developed.
51:28.
all there was was simple terminal interfaces like the one we're using and the main use of unix originally was.
51:35.
time sharing a bunch of people logging into the same machine much like athena.
51:40.
and talking to shells a question about system calls and the.
51:46.
compiler how does a compiler handle system calls does assembly generated make a procedure call to some code segment.
51:53.
uh defined by the operating system uh there's a special risk five.
51:58.
instruction that a program can call that transfers control into the kernel so indeed when you write c code that.
52:05.
makes the system called like open or right i mean technically what actually happens is open is a c.
52:12.
function in the c library but the instructions in that function.
52:17.
are really machine instructions it's not you know open the open function that we're calling.
52:23.
isn't a c function it's implemented assembler and the assembly code.
52:30.
consists of this special instruction it's actually called e-call on the risk 5 the special instruction.
52:35.
that transfers control into the kernel and then the kernel looks at the process's memory and registers to figure.
52:42.
out what the arguments were.
52:50.
all right um the next example i want to look at is an example program that calls fork.
52:58.
to create a new process um so this is the very simple use of fork.
53:04.
at line 12 we're calling fork and what fork does is creates a copy.
53:10.
of the memory of instructions and data of the calling process now we have two processes with identical.
53:16.
memory fork the fork system called returns in both processes in the original.
53:23.
process the fork system call returns the process id which is a.
53:29.
an integer greater than zero for in the original process fork returns the process id of the newly.
53:35.
created process and in the newly created process fork returns zero so we sort of break even though the.
53:42.
processes of identical memory can break the symmetry of old versus new.
53:48.
process by the return value from fork then in line 16 you can see code that.
53:53.
checks and says if process id is equal 0 must be the child we must now be running in the child.
54:00.
the course is two processes and in the other process in the calling process which is usually called the parent the process id is.
54:07.
greater than zero so the child will print child and the parent a good parent.
54:14.
and then they'll both exit so when i run for um here's what we get.
54:22.
so it may look like garbage but what's actually happening is that after the fork both of these processes.
54:28.
are running they're both running at the same time um and qmu is actually emulating a multi.
54:34.
a multi-core microprocessor for me so they really are running.
54:39.
at the very same time and so when they produce output they're producing each byte of their output at the same time as.
54:44.
the other process is producing the corresponding byte of its output so the outputs and the two processes are.
54:50.
interleaved um you can see that they're both typing f um they're both going to type fork.
54:56.
returned um so you can see the f from both of them and the o for both of them and they are for both them and so on.
55:02.
and one of them uh you can see the zero at the end of that first line is in the child fourth return zero um and.
55:10.
i'm guessing that the in the parent four return 19 that is the child's.
55:16.
process id is nineteen under exit six that basically means the 19th process that was created since boot um and then one.
55:23.
of them prints child and you can see the ch ild and interleave with that is the other.
55:29.
one pretty parent so this is sort of a silly use of fork but we can see so vividly in.
55:36.
this output that it's created two processes that are and both of them are running we're fork returning both processes and.
55:42.
they're both running but also note that one printed child and the other parent.
55:48.
so it's important that fork returns differently in the two processes.
55:59.
the question is the child process as a result of fork always identical to the parent process or could they be.
56:05.
different i um.
56:11.
in xv6 are identical except for the return value from fork.
56:17.
you know so the instructions are the same the data's the same the stack is is the same um and also both.
56:24.
processes you know the processes are copies and they both have their own separate.
56:30.
address spaces that is you know they both have they both think that their memory starts at zero and.
56:35.
goes on up from there um but but it's different it's different.
56:40.
different memory um for the two of them in a more sophisticated operating system.
56:46.
there are some details which we definitely don't care about um that may occasionally cause parent.
56:53.
and child to differ but in xv6 they're the same except the return value so the memory is the same in addition.
57:00.
the file descriptor table is copied.
57:05.
so if the parent had some files open then the child sees the same set of file.
57:12.
descriptors although the child is seeing them in a copy of the table of file descriptor.
57:18.
information and so we'll see in a moment that it's quite important that.
57:24.
fork copies the table of open file descriptors as well as the memory.
57:31.
okay so uh port creates a new process but when we run stuff in the shell um.
57:38.
the shell indeed creates a new process to run each command that you type but it needs to actually run the command.
57:44.
in it so you know if i type ls we need to the shell forks to create a process to run ls but.
57:51.
there needs to be some way for this for that new process actually run the instructions from the ls program.
57:58.
to load those instructions from the file called lx um and the example program i mean i'll show.
58:04.
you in a minute uh uses echo echo is a very simple command that.
58:09.
just takes whatever arguments you pass to it and writes them into its output and i prepared for you a program called.
58:15.
exec.
58:21.
um which uh run which makes the exact system.
58:28.
called which replaces the calling process with the instructions read from a.
58:33.
particular from the file you specify and loads the instructions from that file.
58:39.
over the current process sort of discard it discarding its current memory and then starts executing those.
58:44.
instructions so the call to exec the system call exec on line 12..
58:52.
it's going to have the effect of the operating system loading the instructions from the file called echo into the current process sort of.
58:59.
replacing the memory of the current process and then starting to execute uh those instructions and in.
59:06.
addition you can pass arguments command line arguments echo exec allows you to pass an array of.
59:12.
command line arguments with just an array of pointers and see line 10 set sets up an array of character.
59:20.
pointers which are essentially strings and initializes that array to be.
59:25.
to contain the strings echo this is echo and that's equivalent to calling running.
59:31.
the act with command with the three arguments this is echo and so when i want exec.
59:38.
indeed um i see this output this is echo but even though i ran the exact command the.
59:44.
exact program what the exact program does is call it the exact system call to replace itself.
59:50.
with echo and so it was really the echo program um producing this output.
59:58.
and uh something about the exact system call that's important for us is that um it exec.
1:00:04.
preserves the current table of file descriptors so whatever files descriptor zero one two.
1:00:10.
etc were referred to before exec they refer to the same thing in this new program whose instructions.
1:00:18.
we've loaded another point is ordinarily exec does not return.
1:00:23.
because exec replaces the current is memory entirely um there's nothing.
1:00:29.
for exec to return to so exact you know reads the instructions from that file and executes them and.
1:00:35.
then that's it um the only time exec returns is if some error occurred.
1:00:40.
that prevented the operating system from running that program for you so for example if the program doesn't.
1:00:45.
exist at all since the exec can't find a file called echo for example.
1:00:51.
then exec would return negative one to signal that you know something i'm wrong.
1:00:58.
it couldn't couldn't find a file so ordinarily exact does not return it only returns if.
1:01:03.
um the kernel couldn't actually run the file for you.
1:01:10.
questions about exec one question in the chat is what is the last zero for in arc v.
1:01:18.
it marks the end of the array um c is so low level that.
1:01:25.
there's no the c array scheme doesn't have a way.
1:01:33.
for code to find out how long the array is and so to tell the kernel that um.
1:01:40.
you know we meant that the array contains echo this is echo and nothing more um we put a zero as the last.
1:01:48.
strip as the last pointer each of those strings in double quotes is actually a pointer to some memory that contains.
1:01:55.
those bytes that fifth element of the array is a pointer whose value is zero.
1:02:01.
the convention is that a pointer whose value is zero or what's called a null pointer um.
1:02:07.
sort of signifies nothing um with it you know we're done and so the code in.
1:02:14.
the kernel has actually walks through this array until it finds the element whose value is zero.
1:02:24.
okay um right so this is how a program can replace itself.
1:02:29.
um with another program from a file but actually when we run stuff in the shell like echo abc.
1:02:35.
or ls or anything else um we don't want to replace the shell we don't want to have the shell just.
1:02:41.
call exact um because that would replace the shell with the echo command and then when echo exited.
1:02:48.
that would be it you know we don't want echo to replace the shell so what the shell actually does is fork and.
1:02:54.
then the child calls it zac and that's an extremely common unix idiom.
1:03:00.
these programs that um want to run a program but regain control what they do is call.
1:03:05.
fork and have the child call exact so here's a simple example this fork exact program.
1:03:14.
so in this program um called fork on line 12 and the child started line 14 we call.
1:03:19.
exec much like before the child process um.
1:03:24.
has to replace itself with the echo command and echo does this thing and then exits.
1:03:31.
and then the parent process regains control because um when the fork returns.
1:03:37.
the greater than zero value in the parent process so the parent process then continues to execute at 19 and unix provides a weight system called.
1:03:45.
line 20 for a process to wait for one of the for a child that it created with four because.
1:03:51.
when i run a command um here on the command line we want uh we want the shell to wait.
1:03:59.
for the command to finish before it prints the prop again before it prints this dollar sign prompt.
1:04:04.
asking me for more input and so it's the wait system call that allows the process to wait for.
1:04:10.
any of its children to return and this status argument is a.
1:04:15.
way for an exiting child to communicate one integer.
1:04:22.
32-bit value from the exiting child um to the waiting parent so in line 17 that.
1:04:28.
argument to exit that one that's the argument to exit the operating system.
1:04:34.
passes that one from the exiting child um to the call to wait at line 20. so.
1:04:39.
weight that the ampersand and weight is passing the address of the status.
1:04:45.
variable to the kernel the colonel fills in that address with the.
1:04:50.
child's argument to exit and the convention in unix is that if a program completes successfully it.
1:04:57.
exit with exits with state of zero but if if it encountered an error.
1:05:02.
as it lines 17 um then the unix convention is that you pass one to exit and so if you care the.
1:05:09.
calling process can look at the status from weight and decide whether the.
1:05:15.
child completed successfully enough professor morris quick question yes.
1:05:21.
about the exact call on 9 15. uh we mentioned not a bit ago that exec will completely go.
1:05:29.
into the echo program and not return to fork exec so.
1:05:34.
would it ever reach lines 16 and 17 well not for this exact code because.
1:05:41.
there happens to be a program called echo but but you know if i modified that code here let me let.
1:05:46.
me just modify this code for you okay so first let me just run fork exact.
1:05:52.
right it actually does execute echo with those arguments we see the output this is echo.
1:05:59.
and we see the child exited to show that uh echo exited successfully and the parent.
1:06:05.
waited for it let me just modify the program for you um instead of echo i'm going to run some.
1:06:12.
command that doesn't exist i actually have to exit out of uh qmu.
1:06:19.
with control a x and then rebuild the whole thing in order to recompile my modified four gigs and i run four.
1:06:26.
pixel yen after modifying and compiling it and this time because the program we're asking to.
1:06:33.
actually the program we're asking to execute doesn't exist.
1:06:39.
exec does return we see the exec failed output and the exit one you see the one there.
1:06:46.
is communicated back to the parent which says the child exited the status one.
1:06:52.
so exec returns back to the calling function when something went wrong yes.
1:07:12.
okay all right um something that uh something to note here that.
1:07:18.
actually i think many of you have already noted is that uh this is a common idiom here this fork.
1:07:24.
followed by an exec and a child um and it's potentially a bit wasteful the fork.
1:07:29.
copies the entire parent process but exec throws away all that copied memory and.
1:07:35.
replaces it with whatever is in the um file that you're running so you know if.
1:07:43.
you're worried about this kind of stuff the copy implied by the fork.
1:07:48.
is in some sense mostly wasted because all that copied memory is just thrown away and replaced by the.
1:07:53.
exact um and this effects actually would be significant for big programs if you have a multi-gigabyte program that calls.
1:08:00.
fork uh and it did indeed copy all the memory would actually uh take a fair fraction of a second.
1:08:05.
perhaps to do the copy which could be a problem um.
1:08:13.
but later in the course you'll actually implement some optimizations in particular something called.
1:08:18.
copy on right fork which will eliminate almost all of the apparent inefficiency of fork.
1:08:25.
copying only to have exact throw away the copy it turns out with a bunch of tricks involving a virtual memory system.
1:08:33.
you can build a fork that's lazy about the copy and that doesn't do in the common case of fork immediately followed.
1:08:40.
by exact um where you don't actually have to do the copy because the child doesn't actually use most of the memory.
1:08:46.
um i think you'll find that's a fun and interesting lab question from chat why does the parent.
1:08:53.
process print parent waiting completely before the child calls exec.
1:09:00.
it's just chance the is it that you know the.
1:09:08.
the observation is that um you know uh it could be that the parent's output.
1:09:15.
could be interleaved with the child's output in the same area that we saw before with the simpler fork example.
1:09:22.
it just happens not to be there's no guarantee that this is the output we would see in fact we shouldn't be surprised if we.
1:09:29.
saw the lines of the output in the other order or interleaved i suspect what's going on.
1:09:35.
is that it takes a bit of time and effort now the exact system calls a little bit.
1:09:41.
expensive because it has to load all those instructions to access the file system and access the disk and.
1:09:46.
read the contents of a file called echo off the disk into memory after.
1:09:51.
allocating some memory and that even after freeing some memory from the old process so there's quite a bit of machinery.
1:09:57.
involved in the exact system call and apparently that takes long enough.
1:10:03.
that the parent can complete producing the output before the exec has finished and started running echo.
1:10:10.
does that make sense i have another question is it convention.
1:10:17.
that the child can't wait for the parent there's not a way unix doesn't have a.
1:10:25.
way for the child there's no straightforward way for the child to wait for the parent.
1:10:31.
the weight system call is sort of the only mechanism available well the.
1:10:37.
weight system call waits for your children and that's it.
1:10:43.
and so what weight is what weight does is um if you have any children and one of them.
1:10:49.
has already exited or does exit then weight will return but you know if you don't have any.
1:10:55.
children say because you are because in this simple case.
1:11:00.
um whether it was just a parent and a child if the child called weight the child.
1:11:07.
doesn't have any children and in that case weight just returns immediately with a minus one error return saying this process doesn't.
1:11:13.
have any children anyway the short answer is there's no way for a child to wait for its parent to exit.
1:11:22.
another question when we say the child copies all the memory from the parent process what i what.
1:11:27.
exactly do we refer to by that i thought the child is going to divide define the variables again.
1:11:37.
um well when you compile us you know um.
1:11:45.
after compilation your c program is just a bunch of instructions in memory that live in ram.
1:11:53.
um and so those can be copied because they're just bytes living in ram.
1:11:59.
those can be copied somewhere else um and with appropriate tricks having to.
1:12:04.
do with setting up a sort of virtual memory mappings um.
1:12:09.
and make the mappings look the same with the child as an apparent you can just copy the parent's memory image to the child.
1:12:15.
and execute it in the child.
1:12:20.
i mean even though we're looking at c programs you should think of them as just a bunch of us machine instructions um.
1:12:27.
which are just bytes in memory that can be copied if a parent has multiple children would.
1:12:33.
wait just return as soon as the first child finishes meaning that there could be some more interleaving with the parent and.
1:12:38.
unfinished children would there need to be multiple separate weights to ensure all children finish.
1:12:44.
yes if you call forth more than one if a sin if a given process calls for twice um.
1:12:52.
then and it wants to wait for both children it has to call weight twice and each call to wait will return.
1:12:58.
as soon as one of the children exits so you don't when weight returns you don't necessarily know which.
1:13:04.
child is exited the weight returns the child's process id as its return value.
1:13:09.
so you can tell after weight returns you know which one it was that exited.
1:13:22.
as a final example um i'd like to show.
1:13:28.
how all of these facilities combine to implement i o redirection so.
1:13:37.
if you remember the shell provides us with this handy syntax and i can say echo hello greater than.
1:13:43.
out and that runs the echo command that argument sending its.
1:13:48.
first that sends this output to the file out and we look it out or better yet run the cap command with.
1:13:57.
its input connected from the out file we can see that saved output from the.
1:14:02.
echo command um the way the shell sets this up.
1:14:09.
is as follows um it uh the shell.
1:14:17.
first forks like on line 13 and then in the child the shell changes the way.
1:14:23.
the file descriptors are set up so that the child's file descriptor one which by convention.
1:14:30.
most programs use for their output the shell changes the child's file.
1:14:36.
descriptor to one to refer to this output file and then runs whatever command.
1:14:42.
you wanted and that leaves the parent shells file descriptor one unchanged so this idiom of forking and.
1:14:49.
in the child um changing around the file descriptors is the usual way in.
1:14:55.
to sort of redirect input and output for a command that you run but not affect.
1:15:00.
the input and output for the calling program because we don't want to redirect the shell's output.
1:15:07.
we only want to redirect the child programs output anyway the way this works we call fork.
1:15:14.
in the usual way line 15 only executes in the child the reason for the close one.
1:15:20.
on line 15 is that in this program we're redirecting just the output of the.
1:15:25.
echo command so when i run this redirect program produces no output itself but it ran.
1:15:32.
echo with this output directed to output.txt so when i look at output.txt.
1:15:39.
i see this expected output the reason for the close one on line 15.
1:15:44.
is that we want one sort of conventional output file descriptor to refer to something else it.
1:15:52.
happens so we don't from the child we don't want to use the file descriptor one that the shell had that's connected to the.
1:15:58.
console um the call to open on line 16 is guaranteed to return one because.
1:16:04.
the semantics of open are that open returns the lowest file descriptor number that's not.
1:16:10.
currently in use um in the calling process since we just closed one.
1:16:15.
and file descriptor 0 is still connected to the console that mean.
1:16:20.
um open is guaranteed to return one so after the.
1:16:25.
line 16 file descriptor 1 is connected to this file when we exec echo echo just writes its.
1:16:32.
output to file scripter one um and now it goes to this file and the cool thing about this is echo had no idea what's going on.
1:16:38.
echo doesn't need to know about io redirection at all it just writes its output to file descriptor one.
1:16:45.
only the shell knows about io redirection.
1:16:52.
this example also illustrates the sort of kind of neatness of the separation.
1:16:58.
between fork and exec the fact that fork and exact are separate system calls.
1:17:04.
separate uh functions means that there's a period of time but.
1:17:09.
in the child between the fork between fork returns and the child and exact in which.
1:17:14.
we're still running the calling processes instructions so the calling process even though it's running.
1:17:21.
even though its instructions are running in the child it's still the calling processes instructions that are executing.
1:17:26.
and so the calling process is still able to change things um still in control up until line.
1:17:32.
19 and this sort of interval between fork and sec uh gives the shell a chance to.
1:17:38.
change what the file descriptors refer to for example any questions about this redirect.
1:17:45.
example.
1:17:55.
all right um got out of time.
1:18:00.
i'll just wrap up we looked at unix's a bunch of the interfaces to unix's i o.
1:18:07.
and process abstractions a thing to take away from this is that the interfaces are relatively simple.
1:18:12.
you just pass integers like file descriptors and process ids back and forth across.
1:18:17.
as arguments to these system calls um but sort of all the functionality inside the.
1:18:24.
interfaces is relatively sophisticated like creating new processes and copying the current process and.
1:18:30.
furthermore i showed some examples of ways in which the abstractions though individually simple.
1:18:36.
combine in useful ways for example to produce iod direction.
1:18:43.
there's a lab due at the end of next week and that lab involves writing more simple utilities like the ones i.
1:18:50.
showed that use the system calls that we discussed so have fun with that lab and i'll see.
1:18:56.
you in class next week and that's it.
1:19:15.
since i'm the one recording um how do i end this first time recording is in lecture i.
1:19:20.
think we exit okay and nothing special i can just exit and it'll be saved somewhere.
1:19:26.
yes awesome.
1:19:32.
and zoom will create some directory and stick the vowel in that directory.
1:19:38.
there's also office hours right after this right yes perfect okay.
1:19:48.
cool all right all right thank you and i'll see you next week thanks.
