
{
  "title":"Efficiency and Order of Growth",
  "content":"« Previous | Next »\nSession Overview This lecture revolves around the topic of algorithmic efficiency. It introduces the random access model (RAM) of computation and \u0026ldquo;big O notation\u0026rdquo; as a way to talk about order of growth. It concludes with binary search.\nSession Activities Lecture Videos Lecture 8: Efficiency and Order of Growth About this Video Topics covered: Efficiency, problem reduction, RAM, best case, worst case, expected case, growth, exponential growth, polynomial growth, logarithmic growth, global variables.\nResources Lecture code handout (PDF) Lecture code (PY) showGrowth code (PY) Recitation Videos Optional Recitation: Algorithm Complexity and Class Review About this Video Topics covered: Big O notation, algorithm complexity, algorithm comparison example, object-oriented programming, Person class example, defensive programming, private attributes, mutability, aliasing.\nResources Recitation handout (PDF) (Courtesy of Sarina Canelake. Used with permission.) Check Yourself Why is efficiency important?\n› View/hide answer\nEfficiency determines how long our programs take to run; when large sets of data are being handled, it can make a huge difference (on the order of years or even millennia) whether our program is efficient or not.\nWhat notation do we use to state complexity?\n› View/hide answer\nBig O notation.\n« Previous | Next »\n"}


