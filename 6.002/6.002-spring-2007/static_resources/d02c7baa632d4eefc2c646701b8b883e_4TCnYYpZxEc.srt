1
00:00:00,000 --> 00:00:09,000
So today we are going to talk
about another process of lumping

2
00:00:09,000 --> 00:00:16,000
or another process of
discretization what will lead to

3
00:00:16,000 --> 00:00:24,000
the digital abstraction.
So today's lecture is titled

4
00:00:24,000 --> 00:00:30,000
"Go Digital".
So let me begin with a usual

5
00:00:30,000 --> 00:00:36,000
review.
And so in the first lecture we

6
00:00:36,000 --> 00:00:41,000
started out by looking at
elements and lumping them.

7
00:00:41,000 --> 00:00:46,000
For example,
we took an element and said for

8
00:00:46,000 --> 00:00:51,000
the purpose of analyzing
electrical properties let's lump

9
00:00:51,000 --> 00:00:57,000
this element into a single
lumped value called a resistor,

10
00:00:57,000 --> 00:01:01,000
R.
And this led to the lumped

11
00:01:01,000 --> 00:01:04,000
circuit abstraction.
The lumped circuit abstraction

12
00:01:04,000 --> 00:01:09,000
says let's take these elements,
connect them with wires and

13
00:01:09,000 --> 00:01:13,000
analyze the properties of these
using a sort of analysis

14
00:01:13,000 --> 00:01:15,000
technique.

15
00:01:22,000 --> 00:01:28,000
So a set of a methods.
We've looked at the KVL,

16
00:01:28,000 --> 00:01:33,000
KCL method.
Another example of a method we

17
00:01:33,000 --> 00:01:39,000
looked at was the node method.
And of this category there is

18
00:01:39,000 --> 00:01:45,000
one method you should remember,
which you can apply to every

19
00:01:45,000 --> 00:01:51,000
single circuit and it will
simply work, is the node method.

20
00:01:51,000 --> 00:01:56,000
For linear circuits other
methods also apply,

21
00:01:56,000 --> 00:01:59,000
and these include
superposition,

22
00:01:59,000 --> 00:02:04,000
Thevenin method,
and in recitation or in your

23
00:02:04,000 --> 00:02:12,000
course notes you would have
looked at the Norton method.

24
00:02:12,000 --> 00:02:15,000
So that's what we did so far.
So this is a toolkit.

25
00:02:15,000 --> 00:02:19,000
So now you have a utility belt
with a bunch of tools in it,

26
00:02:19,000 --> 00:02:21,000
and you can draw from those
tools.

27
00:02:21,000 --> 00:02:24,000
And, just like any good
carpenter, you know,

28
00:02:24,000 --> 00:02:27,000
the carpenter has to cut a
piece of wood.

29
00:02:27,000 --> 00:02:30,000
He could use a chisel.
He could use a saw.

30
00:02:30,000 --> 00:02:34,000
He could use an electric saw.
And the reason you pay

31
00:02:34,000 --> 00:02:39,000
carpenters $80 an hour in the
Boston region is because they

32
00:02:39,000 --> 00:02:42,000
know which tool to use for what
job.

33
00:02:42,000 --> 00:02:46,000
So what we'll learn today is,
so this was one process of

34
00:02:46,000 --> 00:02:49,000
discretization.
We discretized matter.

35
00:02:49,000 --> 00:02:54,000
This gave us the discipline
here that we decided to follow,

36
00:02:54,000 --> 00:02:58,000
lumped matter discipline,
that moved us from Maxwell's

37
00:02:58,000 --> 00:03:03,000
equations into this new
playground called EECS.

38
00:03:03,000 --> 00:03:06,000
Where all elements looked like
these rinky-dinky little values

39
00:03:06,000 --> 00:03:09,000
like resistors and voltage
sources and so on.

40
00:03:09,000 --> 00:03:12,000
What we'll do today,
if that wasn't simple enough,

41
00:03:12,000 --> 00:03:15,000
let's simplify our lives even
further.

42
00:03:15,000 --> 00:03:17,000
What we're going to do is lump
some more.

43
00:03:17,000 --> 00:03:20,000
So what else can we lump?
We've lumped matter,

44
00:03:20,000 --> 00:03:24,000
so all matter is taken care of.
So what can we lump to make

45
00:03:24,000 --> 00:03:26,000
life even easier?
When in doubt,

46
00:03:26,000 --> 00:03:29,000
if things are complicated,
discretize it or lump it,

47
00:03:29,000 --> 00:03:32,000
right?
So what do you think?

48
00:03:32,000 --> 00:03:36,000
What we will do today is lump
signal values.

49
00:03:45,000 --> 00:03:47,000
So we'll just deal with lumped
values.

50
00:03:47,000 --> 00:03:51,000
And this will lead to the
digital abstraction.

51
00:04:02,000 --> 00:04:10,000
And the related reading is
Chapter 5 of the course notes.

52
00:04:15,000 --> 00:04:19,000
So before we do this kind of
lumping, let me motivate why we

53
00:04:19,000 --> 00:04:21,000
do this.
One reason is to simplify our

54
00:04:21,000 --> 00:04:25,000
lives, but there is no need to
just go around simplifying

55
00:04:25,000 --> 00:04:29,000
things just because we can.
Let's try to see if there are

56
00:04:29,000 --> 00:04:34,000
other reasons motivating the
digital abstraction.

57
00:04:34,000 --> 00:04:39,000
So what I would like to start
with is a simple example of a

58
00:04:39,000 --> 00:04:44,000
analog processing circuit that
you should now be able to

59
00:04:44,000 --> 00:04:47,000
analyze.
So I'm going to be motivating

60
00:04:47,000 --> 00:04:51,000
digital.
So let's start with an analog

61
00:04:51,000 --> 00:04:55,000
circuit that looks like this,
two resistors,

62
00:04:55,000 --> 00:05:00,000
R1 and R2.
And what I'm going to do is

63
00:05:00,000 --> 00:05:06,000
apply a voltage source here,
V1, apply another one here,

64
00:05:06,000 --> 00:05:13,000
V2, and make this connection.
And let me call this voltage V

65
00:05:13,000 --> 00:05:20,000
nought and call this my output.
This voltage with respect to

66
00:05:20,000 --> 00:05:25,000
ground node, rather than drawing
this wire here,

67
00:05:25,000 --> 00:05:31,000
I often times draw a ground
here and simply throw ground

68
00:05:31,000 --> 00:05:36,000
wherever I want.
This symbol simply refers to

69
00:05:36,000 --> 00:05:40,000
the fact that the other terminal
is taken at the ground node.

70
00:05:40,000 --> 00:05:44,000
So here is my V nought.
Now, let's go and analyze this

71
00:05:44,000 --> 00:05:46,000
and see what it gives us.
In this example,

72
00:05:46,000 --> 00:05:50,000
V1 and V2 may be outputs of two
sensors, maybe heat sensors or

73
00:05:50,000 --> 00:05:53,000
something like that.
This is a heat sensor on that

74
00:05:53,000 --> 00:05:57,000
side of the room and this is a
heat sensor on this side of the

75
00:05:57,000 --> 00:06:01,000
room.
And I pass their signals

76
00:06:01,000 --> 00:06:05,000
through two resistors and I look
at the voltage there.

77
00:06:05,000 --> 00:06:10,000
So by now you should be able to
write the answer V nought,

78
00:06:10,000 --> 00:06:13,000
or the value V nought almost by
inspection.

79
00:06:13,000 --> 00:06:17,000
Just to show you,
let me use superposition.

80
00:06:17,000 --> 00:06:22,000
When you see multiple sources,
the first thing you should

81
00:06:22,000 --> 00:06:26,000
think about is can I use
superposition to simplify my

82
00:06:26,000 --> 00:06:30,000
life?
And let me do that.

83
00:06:30,000 --> 00:06:35,000
V nought here is the sum of two
voltages, one due to V1 acting

84
00:06:35,000 --> 00:06:38,000
alone and one due to V2 acting
alone.

85
00:06:38,000 --> 00:06:43,000
So what's the voltage here due
to V1 acting alone?

86
00:06:43,000 --> 00:06:48,000
To find out that I short this
voltage, I zero out this voltage

87
00:06:48,000 --> 00:06:52,000
and look at the effect of V1.
So the effect of V1,

88
00:06:52,000 --> 00:06:57,000
if this were shorted out,
is simply V1 x R2 / R1 + R2.

89
00:06:57,000 --> 00:07:02,000
This is now a voltage divider,
right?

90
00:07:02,000 --> 00:07:06,000
A voltage V applied across two
resistors and the output taken

91
00:07:06,000 --> 00:07:09,000
across one resistor.
So that's this value.

92
00:07:09,000 --> 00:07:12,000
Then I could do the second
part.

93
00:07:12,000 --> 00:07:16,000
To look at the effect of V2,
what I will do is short this

94
00:07:16,000 --> 00:07:19,000
voltage and look at the effect
of this.

95
00:07:19,000 --> 00:07:23,000
Now, this voltage is across
this resistor divider.

96
00:07:23,000 --> 00:07:27,000
And so I get R1 / (R1 + R2)
here.

97
00:07:27,000 --> 00:07:30,000
So you'll notice that for
something like this,

98
00:07:30,000 --> 00:07:34,000
if I had applied KVL and KCL of
the node method I would have

99
00:07:34,000 --> 00:07:38,000
gotten a bunch of equations,
but here I wrote it just by

100
00:07:38,000 --> 00:07:41,000
inspection.
You should be able to look at

101
00:07:41,000 --> 00:07:45,000
circuit patterns like this and
write the answers down very

102
00:07:45,000 --> 00:07:48,000
quickly.
Let's say if I chose R1 to be

103
00:07:48,000 --> 00:07:52,000
equal to R2 then V nought would
simply be (V1 + V2) / 2.

104
00:07:52,000 --> 00:07:56,000
So if these two values were
equal, I simply get the output,

105
00:07:56,000 --> 00:08:00,000
the average of the two
voltages.

106
00:08:00,000 --> 00:08:02,000
So this guy is an adder
circuit.

107
00:08:02,000 --> 00:08:05,000
It adds up these two voltages.
But more precisely it's an

108
00:08:05,000 --> 00:08:09,000
averaging circuit.
It takes two voltages and gives

109
00:08:09,000 --> 00:08:12,000
me the average value.
Now, if you have two sensors in

110
00:08:12,000 --> 00:08:16,000
the room, you might think of why
you want to take that average

111
00:08:16,000 --> 00:08:19,000
value to control the temperature
of the room.

112
00:08:19,000 --> 00:08:23,000
But suffice it to say that V
nought is the average of the two

113
00:08:23,000 --> 00:08:26,000
values.
So let me show you a quick demo

114
00:08:26,000 --> 00:08:30,000
of this example and then look at
what the problems are with this

115
00:08:30,000 --> 00:08:33,000
example.
So let's say,

116
00:08:33,000 --> 00:08:36,000
as one example,
I applied a square wave at V1,

117
00:08:36,000 --> 00:08:39,000
which is the top curve,
the green curve,

118
00:08:39,000 --> 00:08:44,000
and I applied a triangular wave
at V2, that's the second one.

119
00:08:44,000 --> 00:08:48,000
As you expect,
the output is going to be the

120
00:08:48,000 --> 00:08:51,000
sum of the two voltages scaled
appropriately.

121
00:08:51,000 --> 00:08:56,000
So notice that I have a square
wave with a superimposed

122
00:08:56,000 --> 00:09:01,000
triangular wave on top.
And I can play around.

123
00:09:01,000 --> 00:09:06,000
What I could do is change the
amplitude of my wave form here.

124
00:09:06,000 --> 00:09:11,000
And, as you notice,
the amplitude of the output

125
00:09:11,000 --> 00:09:14,000
component also changes
accordingly.

126
00:09:14,000 --> 00:09:18,000
So this is one simple example
of an adder circuit,

127
00:09:18,000 --> 00:09:24,000
and the two wave forms get
summed up and I get the output.

128
00:09:24,000 --> 00:09:28,000
So I'll switch to Page 3.
Let me just draw a little

129
00:09:28,000 --> 00:09:35,000
sketch for you here.
Here, what I showed you was I

130
00:09:35,000 --> 00:09:44,000
had a triangular wave coming on
one of these inputs and I had a

131
00:09:44,000 --> 00:09:52,000
square wave on the other one,
and the output looks something

132
00:09:52,000 --> 00:09:54,000
like this.

133
00:10:04,000 --> 00:10:05,000
OK?
No surprise here.

134
00:10:05,000 --> 00:10:11,000
This is a simple analog signal
processing circuit which gives

135
00:10:11,000 --> 00:10:13,000
me the average of two wave
forms.

136
00:10:13,000 --> 00:10:18,000
Now, let me do the following.
Often times I may need to look

137
00:10:18,000 --> 00:10:21,000
at this value some distance
away.

138
00:10:21,000 --> 00:10:26,000
So let's say this person here
wants to look at the value.

139
00:10:26,000 --> 00:10:32,000
So I bring this wire here.
And I also bring the ground

140
00:10:32,000 --> 00:10:38,000
connection and I look at it.
I look at this value here.

141
00:10:38,000 --> 00:10:44,000
And when I have a long wire I
can get noise added onto the

142
00:10:44,000 --> 00:10:48,000
circuit.
So let's say a bunch of noise

143
00:10:48,000 --> 00:10:52,000
gets added into the signal
there.

144
00:10:52,000 --> 00:10:58,000
And what I end up seeing here
is not something that looks like

145
00:10:58,000 --> 00:11:04,000
this but something that looks
like that.

146
00:11:04,000 --> 00:11:08,000
That's not unusual.
And the problem with this is

147
00:11:08,000 --> 00:11:12,000
now when I look at this,
if I'm looking to distinguish

148
00:11:12,000 --> 00:11:15,000
between, say,
a 3.9 and a 3.8,

149
00:11:15,000 --> 00:11:20,000
it's really hard to do that
because my noise is overwhelming

150
00:11:20,000 --> 00:11:23,000
my signal.
I have a real problem,

151
00:11:23,000 --> 00:11:27,000
a real problem here.
Noise is a fact of life.

152
00:11:27,000 --> 00:11:31,000
So what do we do?
This is so fundamental.

153
00:11:31,000 --> 00:11:35,000
Large bodies of courses in
electrical engineering are

154
00:11:35,000 --> 00:11:40,000
devoted to how do I carefully
analyze signals in the presence

155
00:11:40,000 --> 00:11:42,000
of noise?
You'll take courses in speech

156
00:11:42,000 --> 00:11:47,000
processing that look at clever
techniques to recognize speech

157
00:11:47,000 --> 00:11:50,000
in the presence of noise and so
on and so forth.

158
00:11:50,000 --> 00:11:54,000
One technique we adopt that
we'll talk about here,

159
00:11:54,000 --> 00:11:58,000
which is fundamental to EECS,
is using the digital

160
00:11:58,000 --> 00:12:03,000
abstraction.
Let me show you how it can

161
00:12:03,000 --> 00:12:07,000
really help with the noise
problem.

162
00:12:07,000 --> 00:12:13,000
So the idea is value lumping or
value discretization.

163
00:12:13,000 --> 00:12:20,000
Much like we lumped matter,
we've discretized matter into

164
00:12:20,000 --> 00:12:26,000
discrete chunks,
let's discretize value into two

165
00:12:26,000 --> 00:12:31,000
chunks.
Let's simply say that now I'm

166
00:12:31,000 --> 00:12:35,000
going to deal with two values
and I can, say,

167
00:12:35,000 --> 00:12:37,000
call them high,
low.

168
00:12:37,000 --> 00:12:43,000
I have a bunch of choices here.
I may call it 5 volts and 0

169
00:12:43,000 --> 00:12:47,000
volts.
I may call it true and false.

170
00:12:47,000 --> 00:12:53,000
What I'm doing is I'm just
restricting my universe to deal

171
00:12:53,000 --> 00:12:58,000
with just two values,
zero and one.

172
00:12:58,000 --> 00:13:01,000
This is like dealing with a
number system with only two

173
00:13:01,000 --> 00:13:04,000
digits.
And these are zero and one.

174
00:13:04,000 --> 00:13:08,000
So what I've now done is I'm
saying that rather than dealing

175
00:13:08,000 --> 00:13:12,000
with all possible continuous
values, 0.1, 3.9999 recurring

176
00:13:12,000 --> 00:13:16,000
and so on and so forth,
what I'm going to do is simply

177
00:13:16,000 --> 00:13:19,000
deal with a high and a low.
Dealing with this whole

178
00:13:19,000 --> 00:13:22,000
continuum of numbers is really
complicated.

179
00:13:22,000 --> 00:13:26,000
Let me simplify my life and
just postulate that I am going

180
00:13:26,000 --> 00:13:32,000
to be looking at high and low.
Whenever I see something I'll

181
00:13:32,000 --> 00:13:37,000
look at it and say high or low,
is it black or white,

182
00:13:37,000 --> 00:13:39,000
period.
There's no choice here,

183
00:13:39,000 --> 00:13:44,000
just two individual values.
So that sounds simple,

184
00:13:44,000 --> 00:13:47,000
and nice and so on,
but what's the point?

185
00:13:47,000 --> 00:13:52,000
What do we get by doing that?
Let's take our example.

186
00:13:52,000 --> 00:13:55,000
Let's take what might be a
digital system.

187
00:13:55,000 --> 00:14:02,000
Let's take a digital system and
let's say I have a sender.

188
00:14:02,000 --> 00:14:07,000
Much like I sent a signal value
a long distance,

189
00:14:07,000 --> 00:14:13,000
let me have a sender,
and I have a ground as well and

190
00:14:13,000 --> 00:14:18,000
here is a receiver.
This symbol simply says that

191
00:14:18,000 --> 00:14:22,000
both of them share a ground
wire.

192
00:14:22,000 --> 00:14:28,000
So the sender and a receiver.
And what I'm interested in

193
00:14:28,000 --> 00:14:34,000
doing, the sender is interested
in sending a signal to the

194
00:14:34,000 --> 00:14:39,000
receiver.
And in the digital system,

195
00:14:39,000 --> 00:14:44,000
the way I would send a digital
signal is all I can use is ones

196
00:14:44,000 --> 00:14:47,000
and zeros, OK?
So let's say the sender sends

197
00:14:47,000 --> 00:14:51,000
something like this.
The sender wants to send a

198
00:14:51,000 --> 00:14:54,000
value.
This is my time axis and this

199
00:14:54,000 --> 00:14:57,000
is 2.5 volts,
this is 0 volts and this is 5

200
00:14:57,000 --> 00:15:01,000
volts.
My sender has some agreement

201
00:15:01,000 --> 00:15:05,000
with the receiver and says I'm
just going to be sending to you

202
00:15:05,000 --> 00:15:09,000
low values and high values.
And this signal here would

203
00:15:09,000 --> 00:15:12,000
correspond to "0" "1" "0".
It's a symbol.

204
00:15:12,000 --> 00:15:15,000
That's why I have input zero in
quotes there.

205
00:15:15,000 --> 00:15:18,000
We'll go into this in much more
detail later,

206
00:15:18,000 --> 00:15:22,000
but for now suffice it to say
that I'm sending a set of

207
00:15:22,000 --> 00:15:26,000
signals here "0" "1" "0".
This simplistic scheme will not

208
00:15:26,000 --> 00:15:30,000
work in many situations but go
along with this for a few

209
00:15:30,000 --> 00:15:34,000
seconds.
So I send the signal sequence

210
00:15:34,000 --> 00:15:38,000
"0" "1" "0" out here.
And notice that there is a high

211
00:15:38,000 --> 00:15:41,000
and a low.
And the agreement the sender

212
00:15:41,000 --> 00:15:45,000
and the receiver have is that,
look, if you see a value that's

213
00:15:45,000 --> 00:15:48,000
higher than 2.5 volts that's a
high.

214
00:15:48,000 --> 00:15:53,000
If you see a value below 2.5
volts in the wire that's a low.

215
00:15:53,000 --> 00:15:57,000
And I'm going to send a 0 volt
and a 5 volt from here.

216
00:15:57,000 --> 00:16:01,000
So now at the sending site
let's say I don't have any noise

217
00:16:01,000 --> 00:16:06,000
in this system.
Let's say this is my Vn,

218
00:16:06,000 --> 00:16:11,000
some noise being added.
And let's say Vn is 0.

219
00:16:11,000 --> 00:16:18,000
Then in that case I will
receive exactly what is sent "0"

220
00:16:18,000 --> 00:16:22,000
"0" 5, 2.5, 0 volts.
And this is time.

221
00:16:22,000 --> 00:16:25,000
Nothing fancy here,
right?

222
00:16:25,000 --> 00:16:30,000
My receiver receives a "0" "1"
"0".

223
00:16:30,000 --> 00:16:36,000
Now, the beauty of this is that
now suppose I were to impose

224
00:16:36,000 --> 00:16:42,000
noise much like I had noise out
there and Vn was not 0.

225
00:16:42,000 --> 00:16:48,000
Rather Vn was some noise
voltage, let's say 0.2 volts

226
00:16:48,000 --> 00:16:52,000
peak to peak.
Let's say that simply got

227
00:16:52,000 --> 00:16:58,000
superposed on the signal.
In which case what do I get?

228
00:16:58,000 --> 00:17:06,000
What I end up here with is a
signal that looks like this.

229
00:17:06,000 --> 00:17:09,000
So the receiver gets that
signal because a noise is added

230
00:17:09,000 --> 00:17:12,000
into my signal and that's what I
get.

231
00:17:12,000 --> 00:17:14,000
But guess what?
No problem.

232
00:17:14,000 --> 00:17:17,000
The receiver says oh,
yeah, this is a 0 because the

233
00:17:17,000 --> 00:17:21,000
values are less than 2.5,
this is a 1 and this is a 0.

234
00:17:21,000 --> 00:17:24,000
"0" "1" "0".
So here my receiver was able to

235
00:17:24,000 --> 00:17:28,000
receive the signal and correctly
interpret it without any

236
00:17:28,000 --> 00:17:32,000
problems.
So because I used this value

237
00:17:32,000 --> 00:17:36,000
discretization and because I had
this agreement with the

238
00:17:36,000 --> 00:17:39,000
receiver, I had better noise
immunity.

239
00:17:45,000 --> 00:17:48,000
Consequently,
I had what is called a noise

240
00:17:48,000 --> 00:17:51,000
margin.
Noise margin says how much

241
00:17:51,000 --> 00:17:56,000
noise can I tolerate?
And in this situation,

242
00:17:56,000 --> 00:18:00,000
because the sender sends 5
volts and 0 volts,

243
00:18:00,000 --> 00:18:04,000
the 5 volts can creep all the
way down to 2.5,

244
00:18:04,000 --> 00:18:10,000
I'll still be OK.
Similarly, 0 could go all the

245
00:18:10,000 --> 00:18:14,000
way up to 2.5,
I'd still be OK.

246
00:18:14,000 --> 00:18:21,000
So in this case I have a noise
margin of 2.5 volts for a 1 and

247
00:18:21,000 --> 00:18:28,000
similarly 2.5 volts for a 0,
because there are 2.5 volts

248
00:18:28,000 --> 00:18:34,000
between a 0 volt and 2.5.
So notice that I have a nice

249
00:18:34,000 --> 00:18:37,000
little noise margin here,
which simply is the English

250
00:18:37,000 --> 00:18:41,000
meaning of the term there is a
margin for noise.

251
00:18:41,000 --> 00:18:45,000
And even though I can change
the signal value by up to 2.5

252
00:18:45,000 --> 00:18:50,000
volts, the receiver will still
correctly interpret the signal.

253
00:18:50,000 --> 00:18:54,000
So I've decided to discretize
values into highs and lows.

254
00:18:54,000 --> 00:18:57,000
And because of that,
if all I wanted to do in life

255
00:18:57,000 --> 00:19:03,000
is send highs and lows I can
send them very effectively.

256
00:19:03,000 --> 00:19:08,000
There are many complications,
but if all I care about is

257
00:19:08,000 --> 00:19:14,000
sending highs and lows I can
send it with a lot of tolerance

258
00:19:14,000 --> 00:19:17,000
to noise.
So many of you are saying but

259
00:19:17,000 --> 00:19:21,000
what about this,
but what about that?

260
00:19:21,000 --> 00:19:27,000
There are lots of buts here.
And let's take a look at some

261
00:19:27,000 --> 00:19:31,000
of them.
If you look up there.

262
00:19:31,000 --> 00:19:38,000
What I ended up doing was
creating a design space that

263
00:19:38,000 --> 00:19:42,000
looked like this.
This is on Page 6.

264
00:19:42,000 --> 00:19:50,000
What I did was I said with a
range of values from 0 to 5,

265
00:19:50,000 --> 00:19:58,000
what I'm going to do is at 2.5
I drew a line and I said as a

266
00:19:58,000 --> 00:20:05,000
sender if you wanted to send a 0
then you would send a value

267
00:20:05,000 --> 00:20:10,000
here.
And if you wanted to send a 1

268
00:20:10,000 --> 00:20:14,000
you would send a value here.
Similarly, for a receiver.

269
00:20:14,000 --> 00:20:18,000
And if the sender sent a value
all the way up in 5 volts that

270
00:20:18,000 --> 00:20:22,000
was the best thing,
but technically the sender

271
00:20:22,000 --> 00:20:25,000
could send any value between 2.5
and 5.

272
00:20:25,000 --> 00:20:29,000
And if there was no noise then
the receiver could correctly

273
00:20:29,000 --> 00:20:35,000
interpret a 1 if it was above
this and 0 if it was below this.

274
00:20:35,000 --> 00:20:39,000
The problem with this approach
really is that if I allow the

275
00:20:39,000 --> 00:20:44,000
sender to send any value above
2.5 all the way to 5 then there

276
00:20:44,000 --> 00:20:48,000
really is no noise margin in
this situation.

277
00:20:53,000 --> 00:20:55,000
OK?
Because if I allowed the sender

278
00:20:55,000 --> 00:21:00,000
to send any value between 2.5
and 5 then what if I have a

279
00:21:00,000 --> 00:21:04,000
value 2.5 for a 1?
Then I may end up getting very

280
00:21:04,000 --> 00:21:08,000
little noise margin on the other
side.

281
00:21:08,000 --> 00:21:11,000
Worse yet, what if I get a
value 2.5?

282
00:21:11,000 --> 00:21:16,000
That's a much worse situation.
What if the receiver receives a

283
00:21:16,000 --> 00:21:18,000
value of 2.5?
Now what?

284
00:21:18,000 --> 00:21:23,000
What does the receiver do?
The receiver cannot tell

285
00:21:23,000 --> 00:21:28,000
whether it's a 1 or a 0.
The receiver gets hopelessly

286
00:21:28,000 --> 00:21:33,000
confused.
So to deal with that,

287
00:21:33,000 --> 00:21:40,000
I'm going to fix this,
what I'm going to do is the

288
00:21:40,000 --> 00:21:45,000
following.
Switch to Page 7.

289
00:21:45,000 --> 00:21:53,000
What I'll do here is to prevent
the receiver from getting

290
00:21:53,000 --> 00:22:02,000
confused, if the receiver saw
2.5, what I'm going to do is

291
00:22:02,000 --> 00:22:10,000
define what is called "no man's
land".

292
00:22:10,000 --> 00:22:15,000
I'm going to define the region
of my voltage space called the

293
00:22:15,000 --> 00:22:19,000
forbidden region.
And what I'm going to do is,

294
00:22:19,000 --> 00:22:24,000
say, let's say I defined it as
2 volts, 3 volts and 5 volts,

295
00:22:24,000 --> 00:22:28,000
0, 2, 3 and 5.
With my forbidden region,

296
00:22:28,000 --> 00:22:33,000
if I have a sender then I tell
the sender you can send any

297
00:22:33,000 --> 00:22:39,000
value between 3 and 5 for a 1.
And you can send any value

298
00:22:39,000 --> 00:22:44,000
between 2 and 0 for a 0.
To send the symbol 0,

299
00:22:44,000 --> 00:22:50,000
I can send any voltage between
0 and 2, and similarly for 1.

300
00:22:50,000 --> 00:22:55,000
At the receiving side,
if I see any value between 3

301
00:22:55,000 --> 00:23:00,000
and 5, I read that as a 0,
and any value between 0 and 2 I

302
00:23:00,000 --> 00:23:06,000
read that as 2 volts.
So I may label this value VH

303
00:23:06,000 --> 00:23:11,000
and label this threshold VL,
so there's a high threshold and

304
00:23:11,000 --> 00:23:15,000
a low threshold.
So this solves one problem.

305
00:23:15,000 --> 00:23:20,000
Now the receiver can never see
a value in the forbidden region.

306
00:23:20,000 --> 00:23:24,000
Now, I can stand her and
pontificate and say,

307
00:23:24,000 --> 00:23:30,000
oops, that's a forbidden
region, thou shalt not go there.

308
00:23:30,000 --> 00:23:33,000
But what if I get some noise
and a value goes in there?

309
00:23:33,000 --> 00:23:36,000
In real systems values may
enter there.

310
00:23:36,000 --> 00:23:39,000
But what I'm saying,
so this is the beauty of using

311
00:23:39,000 --> 00:23:41,000
a discipline.
Let me use my playground

312
00:23:41,000 --> 00:23:43,000
analogy.
This is my playground.

313
00:23:43,000 --> 00:23:47,000
We got into this playground
using the discrete matter of

314
00:23:47,000 --> 00:23:51,000
discipline, the playground of
EECS, but in that playground

315
00:23:51,000 --> 00:23:55,000
some region of that playground
deals with just high and low

316
00:23:55,000 --> 00:23:57,000
values.
I further restrict the

317
00:23:57,000 --> 00:24:00,000
playground and I say I'm only
going to focus on that

318
00:24:00,000 --> 00:24:06,000
playground in which all signal
values have a forbidden region.

319
00:24:06,000 --> 00:24:09,000
All senders and receivers
adhere to a forbidden region.

320
00:24:09,000 --> 00:24:14,000
And if there is any signal in
this space, in the forbidden

321
00:24:14,000 --> 00:24:16,000
space then my behavior is
undefined.

322
00:24:16,000 --> 00:24:19,000
I don't care.
You want to go there?

323
00:24:19,000 --> 00:24:21,000
Sure.
I don't know what's going to

324
00:24:21,000 --> 00:24:24,000
happen to you.
Now, we're engineers,

325
00:24:24,000 --> 00:24:26,000
right?
So we've disciplined ourselves

326
00:24:26,000 --> 00:24:32,000
to play in this playground.
It's like I tell my 9-year-old,

327
00:24:32,000 --> 00:24:33,000
don't go there,
right?

328
00:24:33,000 --> 00:24:36,000
And of course he wants to go
there.

329
00:24:36,000 --> 00:24:39,000
He says what will happen if I
go there?

330
00:24:39,000 --> 00:24:42,000
And the answer here will be
undefined, OK?

331
00:24:42,000 --> 00:24:45,000
Something really bad could
happen to you.

332
00:24:45,000 --> 00:24:48,000
I don't know what it is but
something really bad,

333
00:24:48,000 --> 00:24:52,000
you know, a lightening bolt or
who knows what,

334
00:24:52,000 --> 00:24:55,000
but something really bad.
And you as a designer of a

335
00:24:55,000 --> 00:25:00,000
circuit can, let's say you were
Intel.

336
00:25:00,000 --> 00:25:02,000
Intel designs its chips.
And let's say Intel decides to

337
00:25:02,000 --> 00:25:05,000
play in this playground and
there is a forbidden region.

338
00:25:05,000 --> 00:25:08,000
So Intel says oh,
it's really easy for me if in

339
00:25:08,000 --> 00:25:11,000
the forbidden region the chip
simply burns up and catches

340
00:25:11,000 --> 00:25:13,000
fire, we'll sell more chips.
That's fine.

341
00:25:13,000 --> 00:25:15,000
Whatever you want.
The key here is that all I'm

342
00:25:15,000 --> 00:25:19,000
saying is that I am going to
discipline myself into playing

343
00:25:19,000 --> 00:25:22,000
in this playground and that's
where I will define my rules,

344
00:25:22,000 --> 00:25:24,000
and you stay within the
boundaries and all the rules

345
00:25:24,000 --> 00:25:28,000
will apply.
It's called a "discipline."

346
00:25:28,000 --> 00:25:31,000
You're disciplining yourselves
to stay within it.

347
00:25:31,000 --> 00:25:34,000
There's no logic to it.
It's just a discipline.

348
00:25:34,000 --> 00:25:37,000
Just do it and you'll be OK.
When we look at practical

349
00:25:37,000 --> 00:25:40,000
circuits and so on,
we have to address the issue of

350
00:25:40,000 --> 00:25:43,000
what happens when things go in
there.

351
00:25:43,000 --> 00:25:45,000
But let's postpone that
discussion.

352
00:25:45,000 --> 00:25:48,000
For now I've solved one of my
problems, which is,

353
00:25:48,000 --> 00:25:52,000
the previous problem was what
does a receiver do if it saw a

354
00:25:52,000 --> 00:25:53,000
2.5?
Now it can't see a 2.5.

355
00:25:53,000 --> 00:25:57,000
But then the receiver asks,
Agarwal, but what if I see a

356
00:25:57,000 --> 00:26:00,000
2.5?
I can tell the receiver you can

357
00:26:00,000 --> 00:26:03,000
do whatever you want to do.
You can stomp it.

358
00:26:03,000 --> 00:26:05,000
You can squish it.
You can burn it.

359
00:26:05,000 --> 00:26:07,000
You can chuck it.
Whatever you want.

360
00:26:07,000 --> 00:26:10,000
It's up to you.
Do whatever you want.

361
00:26:10,000 --> 00:26:13,000
You won't see a value.
If you do, do whatever you

362
00:26:13,000 --> 00:26:14,000
want.
It's undefined.

363
00:26:14,000 --> 00:26:16,000
That works.
So you, as the receiver

364
00:26:16,000 --> 00:26:19,000
designer can do whatever you
want when you see a 2.5.

365
00:26:19,000 --> 00:26:22,000
You can say yeah,
I'll just put out a 1 if I see

366
00:26:22,000 --> 00:26:25,000
a 2.5 or a 2.6.
I'll just do something.

367
00:26:25,000 --> 00:26:27,000
No one cares.
So this is pretty good.

368
00:26:27,000 --> 00:26:32,000
This is pretty good.
We still have a problem,

369
00:26:32,000 --> 00:26:35,000
though.
Do people see the problem here?

370
00:26:35,000 --> 00:26:40,000
This still doesn't quite work.
If Intel did this,

371
00:26:40,000 --> 00:26:46,000
instead of your laptops failing
and blue-screening every hour

372
00:26:46,000 --> 00:26:49,000
they'd be doing it every
millisecond.

373
00:26:49,000 --> 00:26:54,000
So the problem is this
discipline have allowed the

374
00:26:54,000 --> 00:27:00,000
sender to send any value between
3 and 5 as a 1.

375
00:27:00,000 --> 00:27:05,000
And any value between 3 and 5
at the receiver is treated as a

376
00:00:01,000 --> 00:27:08,000
Do you see where the problem

377
00:27:08,000 --> 00:27:09,000
is?
Yes?

378
00:27:09,000 --> 00:27:14,000
The sender sends a 1.99 and the
noise pumps it into forbidden

379
00:27:14,000 --> 00:27:16,000
region.
Exactly.

380
00:27:16,000 --> 00:27:20,000
So the sender says it's
legitimate, I'm Intel.

381
00:27:20,000 --> 00:00:02,000
They've told me stick to 0 and

382
00:27:23,000 --> 00:27:30,000
And Intel parts will be sending
to values between 0 and 2.

383
00:27:30,000 --> 00:27:32,000
And Motorola parts,
which are receivers,

384
00:27:32,000 --> 00:27:35,000
you know they have to receive 0
and 2.

385
00:27:35,000 --> 00:00:02,000
So Intel can send the value,

386
00:27:37,000 --> 00:27:39,000
They can because it's 1.9 out
of 2.

387
00:27:39,000 --> 00:27:42,000
It's legal.
This way I can make really

388
00:27:42,000 --> 00:27:45,000
cheap parts.
But now the problem is that

389
00:27:45,000 --> 00:27:48,000
even the smallest amount of
noise will bump it into the

390
00:27:48,000 --> 00:27:52,000
forbidden region,
and so therefore this one has a

391
00:27:52,000 --> 00:27:54,000
problem.
And the problem is that this

392
00:27:54,000 --> 00:28:00,000
one offers zero noise margin.
There is no noise margin.

393
00:28:00,000 --> 00:28:05,000
There is no margin for noise in
the discipline.

394
00:28:05,000 --> 00:28:10,000
All right, back to the drawing
board, folks.

395
00:28:10,000 --> 00:28:15,000
Switch to Page 8.
Let's get rid of all this stuff

396
00:28:15,000 --> 00:28:20,000
and go back to the drawing
board.

397
00:28:31,000 --> 00:28:35,000
OK, so what do we do now?
How about the following?

398
00:28:35,000 --> 00:28:39,000
How, about as before I say,
as a receiver,

399
00:28:39,000 --> 00:28:44,000
if you see a value between 3
and 5 you treat that as a 1 and

400
00:28:44,000 --> 00:28:49,000
a value between 0 and 2 you
treat that as a 0.

401
00:28:49,000 --> 00:28:52,000
No difference.
So as a receiver same as

402
00:28:52,000 --> 00:28:56,000
before.
But now what I do is I hold the

403
00:28:56,000 --> 00:29:03,000
sender to tougher standards.
I hold the feet of the sender

404
00:29:03,000 --> 00:29:09,000
to the fire and say you have to
adhere to tougher standards.

405
00:29:09,000 --> 00:29:16,000
So what I'm going to do is hold
the sender to tougher standards,

406
00:29:16,000 --> 00:29:21,000
maybe four walls.
That is tell the sender that if

407
00:29:21,000 --> 00:29:27,000
you want to send to 0 or a 1,
for a 1 you have to send a

408
00:29:27,000 --> 00:29:33,000
value between 4 and 5,
and for a 0 a value between 0

409
00:29:33,000 --> 00:29:37,000
and 1.
Sender is now held to tougher

410
00:29:37,000 --> 00:29:41,000
standards.
This is what my chart looks

411
00:29:41,000 --> 00:29:44,000
like.
So now I do have some noise

412
00:29:44,000 --> 00:29:48,000
margin.
Can someone tell me what is the

413
00:29:48,000 --> 00:29:51,000
noise margin here for a 1?
1 volt.

414
00:29:51,000 --> 00:29:57,000
And the reason is that the
lowest voltage a sender can send

415
00:29:57,000 --> 00:30:02,000
is 4 volts, OK?
If the 4 leaks down to 2.99

416
00:30:02,000 --> 00:30:05,000
that's in the forbidden region,
I'm in trouble.

417
00:00:02,990 --> 00:30:08,000
This is my forbidden region

418
00:30:08,000 --> 00:30:10,000
here.
And 2.99 is in the forbidden

419
00:30:10,000 --> 00:30:12,000
region.
I'm in trouble.

420
00:30:12,000 --> 00:30:17,000
So notice that the lowest value
that the receiver can receive is

421
00:30:17,000 --> 00:30:19,000
3 volts.
So if I sent the 4 and sent

422
00:30:19,000 --> 00:30:24,000
this over a long cable to you,
the value can be beaten up by

423
00:30:24,000 --> 00:30:28,000
noise to such an extent that you
may begin receiving 3s but

424
00:30:28,000 --> 00:30:35,000
nothing lower than a 3.
So this is a noise margin,

425
00:30:35,000 --> 00:30:39,000
1 volt.
Similarly, for a 0 the noise

426
00:30:39,000 --> 00:30:44,000
margin is also 1 volt.
So let me label these.

427
00:30:44,000 --> 00:30:48,000
There are four important
thresholds here.

428
00:30:48,000 --> 00:30:53,000
This threshold is called VOL.
V output low.

429
00:30:53,000 --> 00:31:01,000
These have special meanings.
This threshold here is called

430
00:31:01,000 --> 00:31:06,000
VOH, V output high.
This threshold here is called V

431
00:31:06,000 --> 00:31:12,000
input high and this threshold
here is called V input low.

432
00:31:12,000 --> 00:31:19,000
So VOH simply says that senders
must send voltages higher than

433
00:31:19,000 --> 00:31:23,000
VOH.
Receivers must receive values

434
00:31:23,000 --> 00:31:28,000
higher than VIH as a 1.
So these four thresholds

435
00:31:28,000 --> 00:31:33,000
together give you your
threshold.

436
00:31:46,000 --> 00:31:50,000
For the sender gets 2.5,
what does sender do?

437
00:31:50,000 --> 00:31:53,000
It could do that.
So, in that case,

438
00:31:53,000 --> 00:31:57,000
you can do that.
If all you want to do is have

439
00:31:57,000 --> 00:32:03,000
one value here then what you
have is an infinitesimal value

440
00:32:03,000 --> 00:32:07,000
here for the forbidden region.
That's fine.

441
00:32:07,000 --> 00:32:09,000
It's up to you to design it
that way.

442
00:32:09,000 --> 00:32:12,000
You can.
But it turns out that when you

443
00:32:12,000 --> 00:32:14,000
design circuits,
when we see some examples in

444
00:32:14,000 --> 00:32:18,000
the next lecture it turns out to
be fairly practical and easy to

445
00:32:18,000 --> 00:32:21,000
do it this way.
But, again, these are design

446
00:32:21,000 --> 00:32:22,000
choices.
If I'm Intel,

447
00:32:22,000 --> 00:32:25,000
Intel wants all its parts to
work together.

448
00:32:25,000 --> 00:32:28,000
So parts that follow a common
discipline can work together,

449
00:32:28,000 --> 00:32:33,000
right?
Because senders will send

450
00:32:33,000 --> 00:32:38,000
values, receivers will receive
these values here,

451
00:32:38,000 --> 00:32:45,000
so it will simply work.
So the noise margin for a 1

452
00:32:45,000 --> 00:32:52,000
here is simply VOH minus VIH and
the noise margin for a 0 is VIL

453
00:32:52,000 --> 00:32:57,000
minus VOL.
VIL minus VOL is the noise

454
00:32:57,000 --> 00:33:02,000
margin for a 0.
So what do we have here?

455
00:33:02,000 --> 00:33:06,000
What we have here is a
discipline that we've agreed to

456
00:33:06,000 --> 00:33:11,000
follow where senders are held to
a tough standard and receivers

457
00:33:11,000 --> 00:33:16,000
are held to a different standard
so that I allow myself some

458
00:33:16,000 --> 00:33:20,000
margin for error.
And it's up to you as a

459
00:33:20,000 --> 00:33:24,000
designer to choose ranges for
the forbidden region.

460
00:33:24,000 --> 00:33:29,000
Now, you may say that I want to
make my forbidden region as

461
00:33:29,000 --> 00:33:34,000
small as possible.
But you will see in practical

462
00:33:34,000 --> 00:33:37,000
circuits it's very hard to
achieve that.

463
00:33:37,000 --> 00:33:41,000
Practical devices that you get,
they have a natural region that

464
00:33:41,000 --> 00:33:45,000
gets very, very hard to break
apart, and that tends to

465
00:33:45,000 --> 00:33:48,000
establish what that region looks
like.

466
00:33:48,000 --> 00:33:53,000
So to continue with an example
here, I may have the following

467
00:33:53,000 --> 00:33:57,000
voltage wave form for a sender.
So I have some sender,

468
00:33:57,000 --> 00:34:00,000
I have a sender here.

469
00:34:08,000 --> 00:34:13,000
I have VOL, VIL,
VIH, VOH and some other high

470
00:34:13,000 --> 00:34:17,000
voltage.
And then, as a sender,

471
00:34:17,000 --> 00:34:22,000
if I want to send a "0" "1" "0"
then I send a 0.

472
00:34:22,000 --> 00:34:29,000
I have to be within this band.
And then for a 1 I have to be

473
00:34:29,000 --> 00:34:35,000
within this band.
So this is an example of,

474
00:34:35,000 --> 00:34:41,000
say, "0" "1" "0" "1".
And at the receiver --

475
00:34:51,000 --> 00:34:55,000
Let's have VOL,
VIL, VIH, VOH.

476
00:34:55,000 --> 00:35:02,000
So at the receiver,
I interpret any signal below

477
00:35:02,000 --> 00:35:06,000
VIL as a 0.
So I may get some signal that

478
00:35:06,000 --> 00:35:08,000
looks like this.

479
00:35:16,000 --> 00:35:21,000
And I'll still interpret that
as a "0" "1" "0" "1".

480
00:35:21,000 --> 00:35:26,000
So to summarize here,
this discipline that forms the

481
00:35:26,000 --> 00:35:34,000
foundations of digital systems
is called "a static discipline".

482
00:35:41,000 --> 00:36:03,000
The static discipline says if
inputs meet input thresholds --

483
00:36:03,000 --> 00:36:08,000
So if an input to a digital
system meets the input

484
00:36:08,000 --> 00:36:14,000
thresholds then outputs will
meet, or the digital system

485
00:36:14,000 --> 00:36:19,000
should ensure that the outputs
--

486
00:36:24,000 --> 00:36:29,000
Output thresholds.
So this means that if I have a

487
00:36:29,000 --> 00:36:35,000
system like this then if I give
it good inputs.

488
00:36:35,000 --> 00:36:40,000
And by giving it good inputs I
mean for 1s I have signal values

489
00:36:40,000 --> 00:36:45,000
that are greater than VIH and
for 0s signal values which are

490
00:36:45,000 --> 00:36:48,000
less than VIL.
These are valid inputs.

491
00:36:48,000 --> 00:36:53,000
So if my inputs are valid,
that is below VIL for a 0 and

492
00:36:53,000 --> 00:36:57,000
above VIH for a 1 then this
digital system D will produce

493
00:36:57,000 --> 00:37:03,000
corresponding outputs that
follow output thresholds.

494
00:37:03,000 --> 00:37:07,000
For a 1 it will produce outputs
that are greater than VOH and if

495
00:37:07,000 --> 00:37:12,000
it needs to produce a 0 it will
produce outputs that are less

496
00:37:12,000 --> 00:37:15,000
than VOL.
So notice that there is this

497
00:37:15,000 --> 00:37:19,000
tough requirement in digital
systems that for the inputs,

498
00:37:19,000 --> 00:37:23,000
I should recognize as a 1
anything higher than a VIH.

499
00:37:23,000 --> 00:37:27,000
But if I want to produce a 1,
I have to produce a tough 1

500
00:37:27,000 --> 00:37:31,000
like a 4-volt 1.
So there is a discipline that

501
00:37:31,000 --> 00:37:35,000
all my digital systems must
follow, and that discipline is

502
00:37:35,000 --> 00:37:39,000
called a static discipline.
So static discipline encodes

503
00:37:39,000 --> 00:37:42,000
the thresholds,
encodes four thresholds that

504
00:37:42,000 --> 00:37:46,000
all digital systems must follow
so that they can talk to each

505
00:37:46,000 --> 00:37:49,000
other.
So if Intel and Motorola want

506
00:37:49,000 --> 00:37:51,000
to make parts that are
compatible with,

507
00:37:51,000 --> 00:37:55,000
say, Pentium 4 devices then
they will all talk over the

508
00:37:55,000 --> 00:38:00,000
phone or something and agree on
a static discipline.

509
00:38:00,000 --> 00:38:02,000
We will say that,
all right, all my peripherals

510
00:38:02,000 --> 00:38:05,000
will follow a static discipline
with the following volted

511
00:38:05,000 --> 00:38:07,000
thresholds.
And this way parts made by

512
00:38:07,000 --> 00:38:10,000
different manufacturers can
interoperate and still provide

513
00:38:10,000 --> 00:38:11,000
immunity to noise.
Yes.

514
00:38:11,000 --> 00:38:13,000
Question?

515
00:38:19,000 --> 00:38:21,000
Absolutely.
There are many constraints on

516
00:38:21,000 --> 00:38:24,000
how you as a designer choose the
noise margin.

517
00:38:24,000 --> 00:38:28,000
As a designer you want to make
your noise margin as large as

518
00:38:28,000 --> 00:38:32,000
possible.
The larger the noise margin the

519
00:38:32,000 --> 00:38:35,000
better you can tolerate noise
which is why,

520
00:38:35,000 --> 00:38:40,000
how many people have heard of
some devices called rad hard

521
00:38:40,000 --> 00:38:44,000
devices, radiation hard devices?
Some of you have.

522
00:38:44,000 --> 00:38:48,000
There are a bunch of devices.
Different manufacturers make

523
00:38:48,000 --> 00:38:52,000
different kinds of devices for
different markets.

524
00:38:52,000 --> 00:38:57,000
For consumer markets they use
parts which may have relatively

525
00:38:57,000 --> 00:39:01,000
poor noise margins because
consumers can tolerate more

526
00:39:01,000 --> 00:39:05,000
faults.
But if you're building devices

527
00:39:05,000 --> 00:39:09,000
for, say, the medical industry
or for spaceships and so on,

528
00:39:09,000 --> 00:39:13,000
you need to be held to a much,
much tougher standard.

529
00:39:13,000 --> 00:39:16,000
So for those devices you may
end up having much,

530
00:39:16,000 --> 00:39:20,000
much tighter bands in which you
have to operate so you have a

531
00:39:20,000 --> 00:39:23,000
tougher noise margin.
So that leads us to,

532
00:39:23,000 --> 00:39:28,000
given these sort of voltage
thresholds, we now move into the

533
00:39:28,000 --> 00:39:31,000
digital world.
And in the digital world we can

534
00:39:31,000 --> 00:39:33,000
build a bunch of digital
devices.

535
00:39:33,000 --> 00:39:36,000
The first device we will look
at is called a combinational

536
00:39:36,000 --> 00:39:37,000
gate.

537
00:39:42,000 --> 00:39:46,000
A combinational gate is a
device that adheres to the

538
00:39:46,000 --> 00:39:51,000
static discipline,
Page 11, and this is a device

539
00:39:51,000 --> 00:39:56,000
whose outputs are a function of
inputs alone.

540
00:40:03,000 --> 00:40:07,000
So I can build little boxes
which take some inputs,

541
00:40:07,000 --> 00:40:13,000
produces an output where the
outputs are a function of the

542
00:40:13,000 --> 00:40:17,000
existing inputs.
And this kind of a device is

543
00:40:17,000 --> 00:40:22,000
called a combinational gate.
And I can analyze such devices

544
00:40:22,000 --> 00:40:28,000
for the kinds of things that I
would like to do.

545
00:40:28,000 --> 00:40:34,000
Before I go into the kinds of
devices I'd like to build,

546
00:40:34,000 --> 00:40:39,000
let's spend a few minutes
talking about how to process

547
00:40:39,000 --> 00:40:44,000
signals.
How to process digital signals,

548
00:40:44,000 --> 00:40:48,000
Page 10.
So notice that you have two

549
00:40:48,000 --> 00:40:52,000
values, 0 and a 1.
So devices like my

550
00:40:52,000 --> 00:40:55,000
combinational gate,
for example,

551
00:40:55,000 --> 00:41:02,000
can only deal with 0s and 1s.
So I have to come up with some

552
00:41:02,000 --> 00:41:06,000
kind of a mathematics or some
kind of a set of processing that

553
00:41:06,000 --> 00:41:10,000
can work with 0,1 values.
So 0,1 map completely natural

554
00:41:10,000 --> 00:41:15,000
to the logic true and false.
So I can borrow from logic and

555
00:41:15,000 --> 00:41:19,000
use true and false to do my
processing of signals.

556
00:41:19,000 --> 00:41:23,000
So if all I care about is
processing logic values,

557
00:41:23,000 --> 00:41:29,000
0s and 1s, trues and falses
then that's all I need.

558
00:41:29,000 --> 00:41:33,000
I can also use numbers.
How do I represent a number?

559
00:41:33,000 --> 00:41:38,000
3.9 which is 0s and 1s.
It turns out that this is a

560
00:41:38,000 --> 00:41:43,000
whole field in itself.
You'll hear more about this in

561
00:41:43,000 --> 00:41:46,000
recitation.
Let me also point you to the

562
00:41:46,000 --> 00:41:52,000
last section of the course
notes, Chapter 5.6 I believe,

563
00:41:52,000 --> 00:41:57,000
that talks about how to
represent numbers.

564
00:41:57,000 --> 00:42:01,000
The basic insight is much like
you can represent arbitrary long

565
00:42:01,000 --> 00:42:05,000
numbers with the digits 0
through 9 in the same way,

566
00:42:05,000 --> 00:42:09,000
but concatenating digits you
can represent arbitrary long

567
00:42:09,000 --> 00:42:11,000
numbers with 0-1-1-1-0-0 and so
on.

568
00:42:11,000 --> 00:42:15,000
So you can have a whole
sequence of digits and you can

569
00:42:15,000 --> 00:42:19,000
build a binary number system.
So you can read A&L Section

570
00:42:19,000 --> 00:42:22,000
5.6, I believe.
It's the last section for

571
00:42:22,000 --> 00:42:24,000
numbers.
And you will also discuss this

572
00:42:24,000 --> 00:42:31,000
in your recitation tomorrow.
Let me spend some more time

573
00:42:31,000 --> 00:42:36,000
talking about Boolean logic,
two-valued logic,

574
00:42:36,000 --> 00:42:40,000
and how to process these
systems.

575
00:42:40,000 --> 00:42:46,000
So one way of processing it is
using logic statements of the

576
00:42:46,000 --> 00:42:52,000
following form.
If X is true and Y is true then

577
00:42:52,000 --> 00:43:00,000
Z is true, else is Z false.
So this is a logic statement.

578
00:43:00,000 --> 00:43:04,000
It says if X is true and Y is
true then Z is true,

579
00:43:04,000 --> 00:43:08,000
else Z is false.
So I can process this with 0s

580
00:43:08,000 --> 00:43:13,000
and 1s, trues and falses.
And I do this all the time so I

581
00:43:13,000 --> 00:43:16,000
have a succinct notation for
this.

582
00:43:16,000 --> 00:43:20,000
I express this as Z is X anded
with Y.

583
00:43:20,000 --> 00:43:24,000
X and Y is Z.
So Z is true if X is true and Y

584
00:43:24,000 --> 00:43:27,000
is true.
A shorthand notation for this

585
00:43:27,000 --> 00:43:33,000
is just a dot.
And a circuit notation for this

586
00:43:33,000 --> 00:43:38,000
is called an "AND gate".
That's a little circuit.

587
00:43:38,000 --> 00:43:41,000
I haven't told you what's
inside it.

588
00:43:41,000 --> 00:43:47,000
It's an abstract little device
called an AND gate which takes

589
00:43:47,000 --> 00:43:54,000
two inputs, produces one output
Z where the output is related to

590
00:43:54,000 --> 00:43:59,000
the inputs in the following
manner.

591
00:43:59,000 --> 00:44:03,000
That's a little device called
an AND gate.

592
00:44:03,000 --> 00:44:07,000
I could also represent logic in
truth tables.

593
00:44:07,000 --> 00:44:12,000
And truth tables simply
enumerate all the values and the

594
00:44:12,000 --> 00:44:17,000
corresponding outputs.
Inputs can be 0-0-0-1-1-0 or

595
00:44:17,000 --> 00:44:21,000
1-1.
For an AND system output is 1,

596
00:44:21,000 --> 00:44:25,000
only if both are ones,
it's a 0 otherwise.

597
00:44:25,000 --> 00:44:30,000
So that's a truth table for AND
gate.

598
00:44:30,000 --> 00:44:36,000
So from 0s and 1s we deal with
logic and we create devices like

599
00:44:36,000 --> 00:44:40,000
the AND gate to process digital
signals.

600
00:44:40,000 --> 00:44:46,000
And what we will do is look at
a whole bunch of little symbols

601
00:44:46,000 --> 00:44:51,000
like this, like the AND gate to
process our input signals.

602
00:44:51,000 --> 00:44:57,000
And these devices might look
like other functions like OR

603
00:44:57,000 --> 00:45:03,000
gates and so on.
Let me show you a quick demo.

604
00:45:03,000 --> 00:45:09,000
What I'm going to show you is a
signal feeding an AND gate.

605
00:45:09,000 --> 00:45:15,000
And one signal is going to look
like this, and my signal Y is

606
00:45:15,000 --> 00:45:21,000
going to look like this.
So you expect a processed

607
00:45:21,000 --> 00:45:23,000
output.
So 1-0-1-0-1-0-1.

608
00:45:23,000 --> 00:45:29,000
And the output is simply going
to be --

609
00:45:29,000 --> 00:45:31,000
This is my time axis going this
way.

610
00:45:31,000 --> 00:45:35,000
It is going to be an AND-ing of
these two signal values like so.

611
00:45:35,000 --> 00:45:39,000
What I'm also going to show you
is I'm going to superimpose

612
00:45:39,000 --> 00:45:43,000
noise on this wire.
I'm going to superimpose noise

613
00:45:43,000 --> 00:45:47,000
on the wire, and what I want you
to observe is the output of this

614
00:45:47,000 --> 00:45:50,000
digital gate.
The output will stay exactly

615
00:45:50,000 --> 00:45:52,000
like this, even though I impose
noise.

616
00:45:52,000 --> 00:45:55,000
The ultimate test.
So stay right there.

617
00:45:55,000 --> 00:46:00,000
Let's do this demo.
Give me a couple of seconds.

618
00:47:42,000 --> 00:47:45,000
If you look at the signal up
there, look at the middle wave

619
00:47:45,000 --> 00:47:49,000
form, and I'm imposing let's
have a digital system in a noisy

620
00:47:49,000 --> 00:47:52,000
environment like a lumberyard,
for example,

621
00:47:52,000 --> 00:47:56,000
or chopping a bunch of trees in
my backyard and building digital

622
00:47:56,000 --> 00:48:00,000
systems on the side.
And if I have my buddies

623
00:48:00,000 --> 00:48:04,000
revving up chainsaws
superimposing noise on my second

624
00:48:04,000 --> 00:48:10,000
input, but look at the output.
And just to show that I'm not

625
00:48:10,000 --> 00:48:13,000
bluffing here,
what I'll do is I'll pass the

626
00:48:13,000 --> 00:48:17,000
noise through and make the noise
larger.

627
00:48:17,000 --> 00:48:22,000
And you'll notice that when the
noise begins to surpass the

628
00:48:22,000 --> 00:48:26,000
noise margins the output begins
to go berserk.

629
00:48:26,000 --> 00:48:31,000
Watch.
Can you increase it gradually?

630
00:48:31,000 --> 00:48:35,000
Notice that as I put in a lot
more noise then the output

631
00:48:35,000 --> 00:48:40,000
begins to go berserk,
but as long as my input is

632
00:48:40,000 --> 00:48:45,000
within the noise margin my
output stays perfectly stable.

633
00:48:45,000 --> 00:48:48,000
So that's the "Intro to Digital
Systems".

634
00:48:48,000 --> 00:48:51,000
You'll see numbers in
recitation.

635
00:48:51,000 --> 00:48:54,000
And we'll see you at lecture on
Tuesday.